% place *.rnw inside mizer/vignettes
% RCMD build mizer
% To make the tar ball which includes the compiled pdf
% RCMD INSTALL --build mizer.tar.gz****
% To make the windows binary from the tarball. This binary zip file contains the vignette in pdf form
% In R, load the library then
% vignette("mizer_vignette") to open the vignette

% TODO
% Add units to the parameter table
% Improve all examples
% Add section on how to choose MizerParams argument values


% For checking the latex works OK
% setwd("c:/Projects/sizeBMR/mizer/vignettes")
% setwd("/media/sf_Projects/sizeBMR/mizer/vignettes")
% Sweave("mizer_vignette.rnw", syntax="SweaveSyntaxNoweb")
% shell("pdflatex mizer_vignette.tex")
%
% shell("bibtex mizer_vignette")


\documentclass{article}
\setlength{\parindent}{0pt}	% Eliminate the indent at the beginning of a new paragraph
%\setcounter{secnumdepth}{0}	% Elimate the section numbering starting from a specific depth (see WikiBook)
\setcounter{secnumdepth}{3}	% Elimate the section numbering starting from a specific depth (see WikiBook)
\usepackage[round,sort]{natbib} 
\usepackage{fixltx2e}
\usepackage{graphicx}	% To manage external pictures
\usepackage{float}
\usepackage{subfig}	% To add subfigures within figures, with labels (see WikiBooks)
\usepackage{tabularx}
\usepackage{verbatim}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\usepackage{amssymb,amsbsy,amsmath}
\usepackage{epsfig}
\usepackage[left=3cm,top=3cm,bottom=3.5cm,right=3cm]{geometry}	% For easy management of document margins
\usepackage{fancyhdr} % To customize the header/footer (see WikiBooks)
\usepackage{rotating}
\usepackage{authblk}
\numberwithin{equation}{section}	% Equation numbers relative to sections

%% Set PDF 1.5 and compression, including object compression
%% Needed for MiKTeX -- most other distributions default to this
\ifx\pdfoutput\undefined
\else
  \ifx\pdfoutput\relax
  \else
    \ifnum\pdfoutput>0
      % PDF output
      \pdfminorversion=5
      \pdfcompresslevel=9
      \pdfobjcompresslevel=2
    \fi
  \fi
\fi

% ---------------------------------------------------------------------------------------------------------------------------------------

%\VignetteIndexEntry{Introduction to mizer}
%\VignettePackage{mizer}
%\documentclass{amsart}
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\pkg}[1]{{\texttt{#1}}}
\newcommand{\class}[1]{{\textit{#1}}}
\newcommand{\R}{{\normalfont\textsf{R }}{}}

\begin{document}

% This stuff came from abc vignette
% <<label=R options,echo=FALSE>>=
% options(width = 60)
% options(SweaveHooks = list(fig = function() par(mar=c(3,3,1,0.5),mgp = c(2,1,0))))
% @

%\SweaveOpts{prefix.string=fig,include=F,keep.source=T,eps=FALSE}

% <<echo=false>>=
% options(continue="  ")
% @
% %@% TO ELIMINATE THE "+" IN CONSECUTIVE SCRIPT LINES

\title{Multi-species size-based ecological modelling in \R (\pkg{mizer}): An introductory vignette}
%\author{F. Scott, J. Blanchard, K. H. Andersen}
\author[*]{F. Scott}
\author[**]{J. Blanchard}
\author[***]{K. H. Andersen}
\affil[*]{Cefas, Lowestoft, UK}
\affil[**]{University of Sheffield, UK}
\affil[***]{DTU Aqua, Copenhagen, DK}
\renewcommand\Authands{ and }
\date{\pkg{mizer} version \Sexpr{packageDescription("mizer")[["Version"]]} , \Sexpr{Sys.Date()} }
\maketitle

\tableofcontents
\setcounter{footnote}{1} \footnotetext{This document is included as a
  vignette (a \LaTeX\ document created using the \R function
  \code{Sweave}) of the package \pkg{mizer}. It is automatically
  dowloaded together with the package and can be accessed through \R
  typing \code{vignette("mizer\_vignette")}.}  \newpage
\setlength{\parskip}{4pt} % Space between paragraphs

<<echo=FALSE>>=
rm(list=ls())
@ 

\section{Summary}

\pkg{mizer} is a package for \R that implements size-based ecological models.
The package has been developed to model marine ecosystems that are subject
to fishing.
However, it may also be appropriate for other ecosystems.
The package contains routines and methods to allow users to set up the model
community,
and then project it through time under different fishing strategies.
Methods are included to explore the results, including plots and 
calculation of community indicators such as the slope of the size spectrum.
Size-based models can be complicated so \pkg{mizer} contains many default
options that can be easily changed by the user.

\section{Introduction}

\subsection{Installation}
% Freely borrowed from abc Vignette - ask the authors
\R is a open source software project and can be freely downloaded from the CRAN website. There are already several resources for an introduction to \R.  The CRAN website link to contributed documentation also offers excellent introductions in several languages. Once \R is running, the installation of additional packages is quite straightforward.  To install the \pkg{mizer} package from \R simply type:

%\vspace{2mm}
%\noindent
%\texttt{> install.packages("mizer")}

<<eval=FALSE>>=
install.packages("mizer")
@

%\vspace{2mm}
%\noindent
Once the \pkg{mizer} package is installed, it needs to be made
accessible to the current \R session by the command:
<<results = hide>>=
library(mizer)
@

For an overview of the package documentation or the details of a particular command
(such as the function \texttt{project}) you can type:
<<eval=FALSE>>=
help(package="mizer")
help(project)
@ 

The first command gives a brief summary of the available commands in
the package, the second give more detailed information about a
specific command.

\subsection{Methods and classes in \R}

This is only a brief reminder that expressions in \R manipulate
objects, which may be data (a scalar or a matrix for example), but
objects may also be functions, or more complex collections of objects.
All objects have a class, which enables functions to act on them
appropriately. Thus, for example, when the function \code{summary}
is applied on an object of class \class{MizerParams} (the class
that stores the model parameters), it would act
differently than on a simple matrix.

\section{The principles of size-based modelling}
\label{sec:principles}

Describe the basic principles of size-based modelling.

Abundance of individuals decreases with body size leading to a 'size spectrum'.

Big things eat little things.

Food dependent growth.

Changes in the size spectrum as an indicator (LFI, MW, slope).

References to:
Sheldon and Parsons (1967);
Andersen and Beyer (2006);
\cite{andersen_damped_2010}
NORTH SEA PAPER etc.

\subsection{The model}
\label{sec:model_equations}

Describe the model here.

See Table~\ref{tab:model_params}.

Assumptions.

Check equations and notations are correct and consistent with NSPAPER

Prey size selection (unitless):
\begin{equation}
\label{eqtn:prey_size_selection}
\phi \left(\frac{w_{prey}}{w} \right) = exp \left[-\left(ln\left(\frac{\beta w_{prey}}{w}\right)\right)^2 / (2 \sigma^2 )\right]
\end{equation}

??????
Search rate or is this search volume? Units:
\begin{equation}
\label{eqtn:search_rate}
V(w) = \gamma w^q
\end{equation}

Encountered food:
?????? Is this a rate? Or just mass?
\begin{equation}
\label{eqtn:encountered_food}
%E(w) = V(w) \sum_{j} \theta_{ij} \int_0^\infty N_j(w_p)w_p dw_p
E(w) = V(w) \int N_{prey}(w_{prey}) w_{prey} \phi(w_{prey}/w) dw_{prey}
\end{equation}

Maximum consumption:
RATE OR NOT?
\begin{equation}
\label{eqtn:max_consumption}
I_{max} = h w^n
\end{equation}

Feeding level:
\begin{equation}
\label{eqtn:feeding_level}
f(w) = \frac{E(w)}{E(w) + I_{max}}
\end{equation}

Maturation function:
\begin{equation}
\label{eqtn:maturation}
\psi(w) = \left[1 + \left(\frac{w}{w_{mat}} \right)^{-10}\right]^{-1} \left( \frac{w}{w_{\infty}}\right)^{1-n}
\end{equation}

Somatic growth:
UNIT? RATE?
\begin{equation}
\label{eqtn:somatic_growth}
g(w) = (\alpha f(w) I_{max} - k w^p)(1 - \psi(w))
\end{equation}

Gonadal growth:
\begin{equation}
\label{eqtn:gonadal_growth}
g_r(w) = (\alpha f_i(w) I_{max} - k w^p) \psi(w)
\end{equation}

Density independent recruitment:
\begin{equation}
\label{eqtn:di_recruitment}
\varepsilon / (2w_0 N(w_0)g(w_0))\int N(w)g_{r}(w)dw
\end{equation}

Background mortality:
\begin{equation}
\label{eqtn:background_mortality}
\mu_0 = z_0 w_{\infty}^z
\end{equation}

Predation mortality:
\begin{equation}
\label{eqtn:predation_mortality}
\mu_{p}(w) = \sum_{pred} \int_{w_0}^\infty \phi \left(\frac{w^{'}}{w} \right) (1 - f_{pred}(w^{'})) V(w^{'}) \theta_{i,{pred}} N_{pred}(w^{'})dw^{'}
\end{equation}

Growth of the resource spectrum:
\begin{equation}
\label{eqtn:resource_growth}
\frac{\delta N_r(w)}{\delta t} = r_0 w^{n-1}(k(w) - N_r(w)) - \mu_{p,r}(w) N_r(w)
\end{equation}

Carrying capacity of the resource spectrum:
\begin{equation}
\label{eqtn:carrying_capacity}
k(w) = k_r^{-\lambda}
\end{equation}

\begin{table}[ht]
    \begin{center}
	\begin{tabularx}{\linewidth}{r|X|X}
	    \hline
	    Parameter & Description & Units \\
	    \hline

$\phi$ & Size selection of food items. & - \\
w & Mass of individual. & g \\
$\beta$ & Preferred predator-prey mass ratio. & - \\
$\sigma$ & Width of food selection function & - \\
V & Volumetric search rate OR IS IT VOLUME? & ??? \\
$\gamma$ & Factor for search volume & - \\
q & Exponent of search volume & ??? \\
E & Encountered food. & g ????  \\
$N_{prey}$ & Abundance of prey available i.e. after the interaction matrix. & \\
$I_{max}$ & Maximum consumption.& g \\
h & Factor for maximum intake. & - \\
n & Exponent of maximum intake. & - \\
f & Feeding level. & - \\
$\psi$ & Allocation to reproduction. & - \\
$w_{mat}$ & Maturation weight. & g \\
g & Somatic growth. & g ?????\\
$\alpha$ & Assimilation efficiency. & \\ 
k & Factor for standard metabolism. & \\
p & Exponent for standard metabolism. & \\
$g_r$ Gonadal growth. & ???? \\
$\varepsilon$ & Density independent recruitment. & ???? \\
$w_0$ & Size at recruitment.& g \\
g & ???? from DI recruitment & \\
$\mu_0$ & Background mortality. & \\ 
$z_0$ & Factor for background mortality. & \\
$z$ & Exponent for background mortality. & \\


	\end{tabularx}
	\caption{Parameters in the size-based model.}
	\label{tab:model_params}
    \end{center}
%\end{sidewaystable}
\end{table}

Interaction matrix

etc


\section{Using \pkg{mizer}}

Using \pkg{mizer} is relatively simple.  There are three main stages:

\begin{itemize}
    \item Setting the model parameters. This is done by creating an object of class \class{MizerParams}. This includes model parameters such as the life history parameters of each species, and the range of the size spectrum.
    \item Running a simulation. This is done by calling the \code{project()} method on the model parameters. This produces an object of \class{MizerSim} which contains the results of the simulation.
    \item After a simulation has been run, the results can be explored using a range of plots and summaries.
\end{itemize}

These stages are explained in the following sections.

\section{Setting the model parameters using \class{MizerParams}}

Before any simulations can be run it is necessary to set the parameters
of the model.
This is probably the most complicated part of the using the \pkg{mizer} package so
we will take it slowly.

The \pkg{mizer} package has its own class for storing model parameters: \class{MizerParams}.
This class stores the:
\begin{itemize}
    \item life-history parameters of the species in the community, such as $W_{\infty}$;
    \item size-based biological parameters for the species, such as the search volume, $V(w)$;
    \item stock-recruitment relationship functions and parameters of each species;
    \item interaction matrix to describe the spatial overlap of pairs of species;
    \item parameters relating to the growth and dynamics of the background resource spectrum;
    \item fishing gear parameters: selectivity and catchability.
\end{itemize}

Note that the \class{MizerParams} class does not store any parameters that can vary through time,
such as fishing effort or population abundance. These are stored in the \class{MizerSim} class which
we will come to later in Section \ref{sec:projection}.

Although the \class{MizerParams} class seems complicated, it is relatively straightforward to set up and use.
Objects of class \class{MizerParams} are created using the constructor method \code{MizerParams()}.
This constructor method can take many arguments. However, creation is simplified because many of the arguments have default values.

In the rest of this section we look at the main arguments to the \code{MizerParams()}
constructor method.
To help understand how the constructor is used and how the \class{MizerParams} class
relates to the equations given in Section~\ref{sec:principles}, there is an example
section where we create example parameter objects using data that comes with the
\pkg{mizer} package.

\subsection{The species parameters}
\label{sec:species_parameters_dataframe}

Although many of the arguments used when creaing a \class{MizerParams} object are optional, there is one argument that must be supplied by the user: the species specific parameters. 
For each species in the model community you must supply the life-history parameters, the selectivity function parameters and the stock-recruitment function parameters.

The species parameters must all be stored in a single data.frame object.  The data.frame is arranged species by parameter, so each column of the parameter data.frame is a parameter and each row has the parameters for one of the species in the model.
Although it is possible to create the data.frame by hand in \R, it is probably easier to create the data externally as a .csv file (perhaps using a suitable open source spreadsheet such as LibreOffice) and then read the data into \R.

There are some essential columns that you must include in the parameter data.frame and that do not have default values.
Other columns do have default values, so that if you do not include them in the species parameter data.frame, they will be automatically added when the \class{MizerParams} object is created. 
A description of the columns of the species parameter data.frame and any default values can be seen Table~\ref{tab:species_params}.

LINK THESE PARAMETERS TO THE EQUATIONS IN SECTION 3


%\begin{sidewaystable}[ht]
\begin{table}[ht]
    \begin{center}
	%\begin{tabular}{r|p{7cm}|p{7cm}}
	%\begin{tabularx}{r|X|X}
	    %\begin{tabularx}{\linewidth}{r|p{7cm}|X}
	    \begin{tabularx}{\linewidth}{r|X|X}
	    \hline
	    Column name & Description & Default value \\
	    \hline
	    \multicolumn{3}{c}{Life history parameters} \\
	    \hline
	    species & Name of the species & Compulsory (no default)\\
	    w\_inf & The asymptotic mass of the species & Compulsory (no default)\\
	    w\_mat & Maturation mass. Used to calculate values for $\psi$. WHAT IS WMAT IN TERMS OF BIOLOGY? Is it the mass at first maturity? & Compulsory (no default)\\
	    h & Maximum food intake rate & Compulsory (no default) \\
	    gamma & Volumetric search rate & Compulsory (no default)\\
	    k & Activity coefficient & Compulsory (no default)\\
	    ks & Standard metabolism coefficient & Compulsory (no default)\\
	    beta & Preferred predator prey mass ratio & Compulsory (no default)\\
	    sigma & Width of prey size preference & Compulsory (no default)\\
	    z0 & Background mortality (constant for all sizes) & Compulsory (no default)\\
	    alpha & Assimilation efficiency & 0.6 \\
	    erepro & Reproductive efficiency & 1 \\
	    w\_min & The size class that recruits are placed in. & smallest size class of the species size spectrum \\
	    \hline
	    \multicolumn{3}{c}{Fishing gear parameters (see Section~\ref{sec:fishing_gear} for more details).} \\
	    \hline
	    sel\_func & The name of the selectivity function to be used.  & "sigmoid\_length".\\
	    gear & The name of the fishing gear that selects the species. At the moment a species can only be selected by one gear. & Name of the species \\
	    catchability & The catchability of the fishing gear. & 1\\
	    %a & Length-weight conversion coefficient & Only necessary if length-weight conversion is used (e.g. if specifying length ranges when calculating indicators, or in the fishing selectivity function) \\
	    %b & Length-weight conversion power & See notes for column $a$\\
	    other columns & Other parameters used by the selectivity function. For example, if the default "sigmoid\_length" function is used then the parameters "l25","l50","a" and "b" must also be specified as columns (see Section~\ref{sec:fishing_gear}). & \\ 
	    \hline
	    \multicolumn{3}{c}{Stock recruitment parameters (see Section~\ref{sec:srr} for more details).} \\
	    \hline
	    other columns & Any arguments that appear in the stock-recruitment function must also have a column of values (see Section~\ref{sec:srr}) & \\
	%\end{tabular}
	\end{tabularx}
	\caption{Columns of the species parameters data.frame}
	\label{tab:species_params}
    \end{center}
%\end{sidewaystable}
\end{table}

You can see in Table~\ref{tab:species_params} that most of the species specific
parameters relate to the life history of the species.
The others relate to the gear selectivity function and the stock-recruitment relationship.
These are explained further in Sections~\ref{sec:fishing_gear} and \ref{sec:srr} respectively. 



\subsection{Fishing gears and selectivity}
\label{sec:fishing_gear}
%As well as life-history parameters, the parameter data.frame must also have columns that specify
%parameter values for the chosen fishing selectivity function. This is covered in more detail
%in Section~\ref{sec:fishing_gear}. In brief, any parameter that is used in the selectivity
%function (apart from size) must also be included in the parameter data.frame.
%For example, the default selectivity function uses the parameters \code{l25}, \code{l50},
%\code{a} and \code{b}. This means that if the default selectivity function is being used then
%these must also be included in the parameter data.frame.

In this section we take a look at how fishing is implemented and how fishing gears are set up within
\pkg{mizer}.

In \pkg{mizer}, fishing mortality is imposed on species by fishing gears.
The fishing mortality $F$ imposed by gear $g$ on species $s$ at size $w$ is calculated as:

\begin{equation}
    F_{s,g,w} = S_{s,g,w} Q_{s,g} E_{g}
\end{equation}

where $S$ is the selectivity by species, gear and size, $Q$ is the catchability by species
and gear and $E$ is the fishing effort by gear.
The selectivity at size has a range between 0 (not selected at that size) to 1 (fully selected at
that size).
Catchability is used as an additional scalar to make the link between gear selectivity, fishing
effort and fishing mortality. 
For example, it can be set so that an effort of 1 gives a desired fishing mortality.
In this way effort can then be specified relative to a 'base effort', e.g. the effort
in a particular year.
Fishing effort is not stored in the \class{MizerParams} object.
Instead, effort is set when the simulation is run and can vary through time (see Section~\ref{sec:projection}).

At the moment a species can only be selected by one fishing gear, although each gear can select more than one species (this is a limitation with the current package that will be developed in future releases).

The selectivity at size of each gear is given by a selectivity function. Some selectivity
functions are included in the package. New functions can be defined by the user. 
Each gear has the same selectivity function for all the species it selects, but the parameter
values for each species may be different, e.g. the lengths of species that a gear selects may be different.

The name of the selectivity function is given by the $sel\_func$ column in the species parameters data.frame.
Each selectivity function has a range of arguments. Values for these arguments
must be included as columns in the species parameters data.frame. The names of the columns must exactly
match the names of the arguments. 
For example, the default selectivity function is \code{sigmoid\_length}.
The arguments for this selectivity function can be seen in the help page
for this function. To see them enter:

<<eval=FALSE>>=
?sigmoid_length
@

It can be seen that the \code{sigmoid\_length} function has arguments \code{w}, \code{l25},
\code{l50}, \code{a} and \code{b}.
The first argument, \code{w}, is size (the function calculates selectivity at size).
All selectivity functions must have \code{w} as the first argument.
The values for the other arguments must be found in the species parameters data.frame.
This can be seen in the example in Section \ref{sec:params_example}.
If they are not there, an error is thrown when the \class{MizerParams} object is created.

Users are able to write their own size based selectivity function. The first argument to the
function must be \code{w} and the function must return a vector of the selectivity
(between 0 and 1) at size.

The name of the fishing gear is given in the $gear$ column of the species parameter
data.frame. If the $gear$ column is not specified, the default gear name is simply
the name of the species. This implies that each species is fished by a different gear.
This approach can be used to explore the impacts of changing fishing mortality on individual species.

\subsection{The stock-recruitment relationship}
\label{sec:srr}
%The parameter data.frame may also have columns that relate to the stock-recruitment function.
%This is covered in Section~\ref{sec:srr}.
%In brief, any parameter that is used
%by the stock-recruitment function (apart from the density independent recruitment value)
%must be included in the parameter data.frame.
%For example, the default stock-recruitment function is a Beverton-Holt
%type formulation which uses a parameter called $r_{max}$. Therefore, if the default
%stock-recruitment function is used, a column of values called $r_{max}$ needs to
%be included in the parameters data.frame.

The stock-recruitment relationship in \pkg{mizer} means something slightly
different to the standard fisheries terminology.
In standard fisheries science, 
recruitment means the abundance of new recruits entering the fishery
(e.g. the number of age 1 added to the population each year).
This recruitment is calculated by the stock-recruitment
relationship, based on some measure of the reproductive potential of
the stock, such as spawning stock biomass.

In \pkg{mizer} recruitment means the number of individuals that enter
the size-spectrum at the smallest size group of that species (given by the
parameter $w\_min$ in the species parameter data.frame).
As can be seen in Section~\ref{sec:principles}, 
calculating the recruitment involves calculating the 'density independent'
recruitment, $RDI$ (equation~\ref{eqtn:di_recruitment}).
The $RDI$ is then modified by a stock-recruitment relationship
to impose some form of density-dependence. This then results in the
density-dependent recruitment, $RDD$.
Without this density dependence, the realised recruitment
to the smallest size class is determined only
by $RDI$.

The default stock-recruitment relationship is a Beverton-Holt type function
which has the form:

\begin{equation}
\label{eqtn:default_srr}    
    RDD = \frac{r_{max}.RDI}{r_{max}+RDI}
\end{equation}

where $r_{max}$ is a parameter which determines the maximum recruitment.

% Add a figure

Similar to the fishing selectivity functions, any parameter used in the
stock-recruitment function, other than $RDI$, must be in the species
parameter data.frame and the column must have the same name as the function argument.
For example, if the above default stock-recruitment function is to be
used then the species parameter data.frame must have an $rmax$ column.

Users are able to write their own stock-recruitment function. The first argument to the function must be \code{rdi}.

EXAMPLE - SEE FUNCTION

\subsection{The interaction matrix}
\label{sec:interaction_matrix}

The interaction matrix describes the interaction of each pair of species
in the model. This can be viewed as a proxy for spatial interaction
e.g. to model predator-prey interaction that is not size based.
The values in the interaction matrix are used to scale the size-based predation pressure.
The matrix is square with every element being the interaction between a pair
of species. The dimensions, nrows and ncolumns, therefore equal the number of species.
The values are between 0 (species do not overlap and
therfore do not interact with each other) to 1 (species overlap perfectly).
If all the values in the interaction matrix are set to 1 then predator-prey
interactions are determined entirely by size-preference.

The interaction matrix must be of type \code{array} or \code{matrix}. 
One way of creating your own is to enter the data using a spreadsheet 
(such as LibreOffice) and saving it as a .csv file. 
The data can be read into \R using the commmand \code{read.csv()}. This reads
in the data as a data.frame. We then need
to convert this to a matrix using the \code{as()} function. 
An example of how to do this is given in Section~\ref{sec:params_example}.

It should be noted that the order of species in the interaction
matrix has to be the same as the order in the species parameters data.frame.
Although you can specify the dimnames of the interaction matrix, these names
are overwritten by the species names from the species parameters data.frame
inside the \class{MizerParams} constructor.

If an interaction matrix is not specified to the \code{MizerParams()}
contructor the default interation matrix is used. This has all values set to 1. 

\subsection{The other \code{MizerParams()} arguments}
\label{sec:other_mizerparams_arguments}

As well as the essential species parameters data.frame and the interaction
matrix, there are several other arguments to the \code{MizerParams} constructor.
These have default values.  Although it is tempting to just charge on and use the default
values, many of the values come from a particular model of the
North Sea (REF NSPAPER) and so may not be appropriate for what you are doing.
We'll look at these arguments here, describe what they do and
discuss how to choose appropriate ones for your model (TODO).
The arguments can be seen in Table \ref{tab:other_params}.

\begin{table}[ht]
    \begin{center}
	\begin{tabularx}{\linewidth}{r|X|X}
	\hline
	Argument & Description & Default value \\
	\hline
	min\_w & The smallest size of the species community size spectrum. Note that this a different w\_min to the one in the species parameter data.frame. & 0.001 \\
	max\_w & The largest size of the species size spectrum. & The laegest w\_inf in the species parameters data.frame * 1.1 \\
	no\_w & The number of size bins in the species size spectrum. & 100 \\
	min\_w\_pp & The smallest size of the background size spectrum. & 1e-10 \\
	no\_w\_pp & The number of size bins in the background size spectrum. & round(no\_w) * 0.3 \\
	n & The scaling of intake. & 2/3 \\
	p & The scaling of standard metabolism. & 0.7 \\
	q & The search volume exponent. & 0.8 \\
	r\_pp & The growth rate of the primary productivity (the background spectrum). & 10 \\
	kappa & The carrying capacity of the background spectrum. & 1e11 \\
	lambda & The exponent of the background spectrum. & 2+q-n \\
	w\_pp\_cutoff & The cut off size of the background spectrum. & 10 \\
	\end{tabularx}
	\caption{Other parameters to the \code{MizerParams()} constructor}
	\label{tab:other_params}
    \end{center}
\end{table}

How to choose parameter values.

\subsection{Putting all this together: an example of making a simple \class{MizerParams} object}
\label{sec:params_example}

As mentioned in the preceeding sections, an object of \class{MizerParams}
is created by using the \code{MizerParams()}
constructor method. This takes the following arguments:
\begin{description}
    \item[object] The species parameter data.frame (see Section~\ref{sec:species_parameters_dataframe}). This is compulsory with no default value.
    \item[inter] The interaction matrix (see Section~\ref{sec:interaction_matrix}). The default is a matrix of 1s.
    \item[...] Other model parameters (see Section~\ref{sec:other_mizerparams_arguments}).
\end{description}

In the rest of this section we demonstrate how to pull these elements together
to make \class{MizerParams} objects. 

The first step is to prepare the species specific parameter data.frame.
As mentioned above, one way of doing this is to use a spreadsheet
and save it as a .csv file. We will use this approach here.
An example .csv file has been included in the package.
This file is placed in the $doc$ folder of the package installation.
The location of the file can be found by running:

<<eval=FALSE>>=
system.file("doc/simple_species_params.csv",package="mizer")
@

This file can be opened with most spreadsheets or a text editor for you to inspect.
This can be loaded into \R using the following code (after you
have told \R to look in the right directory):

% Fake one
<<>>=
params_data <- read.csv("simple_species_params.csv")
@ 

This reads the .csv file into \R in the form of a data.frame.
You can check this with the \code{class}:

<<>>=
class(params_data)
@

%The first few lines of the data.frame can be inspected with
%the \code{head()} function.
The example data.frame can be inspected by entering the name
of the object.

<<>>=
params_data
@

This data set is for a model of the North Sea (REFERENCE).
There are \Sexpr{nrow(params_data)} species.
As you can see, we have all the essential life history columns as described in
Table~\ref{tab:species_params}, as well as some additional columns.

There is no $sel\_func$ column to determine the selectivity function.
This means that the default selectivity function, \code{sigmoid\_length},
will be used. However, as mentioned in Section~\ref{sec:fishing_gear},
this function also needs several other arguments. The species data.frame
therefore already includes the columns $a$, $b$, $l25$
and $l50$ for the default selectivity function.

Similarly, the column $r\_max$ is the parameter for the default stock-recruitment
function described in Section~\ref{sec:srr}.

The values of the non-essential species specific parameters $alpha$ and $erepro$,
are not included in the data.frame. This means that the default values
will be automatically used when we create the \class{MizerParams} object.

Strictly speaking, this species parameter data.frame is the minimum
we need to create a
\class{MizerParams} object. However, the model would be improved
by also including a case study specific interaction matrix.

An example interaction matrix has been included in \pkg{mizer}
as a .csv file.  The location of the file can be found by running:

<<eval=FALSE>>=
system.file("doc/inter.csv",package="mizer")
@

Take a look at it in a spreadsheet if you want.
As mentioned above, to read this file into \R we can make
use of the \code{read.csv()} function. However, this time
we want the first column of the .csv file to be the row
names. We therefore use an additional argument to the \code{read.csv()}
function: \code{row.names}.


<<>>=
inter <- read.csv("inter.csv", row.names=1)
@

The \code{read.csv()} function reads the data into a data.frame.
We want the interaction matrix to be of class \class{matrix} so
we need to make use of the \code{as()} function.

<<>>=
inter <- as(inter, "matrix")
@

We now have the species parameters data.frame and the interaction
matrix.
To make the \class{MizerClass} object you just call the constructor method
and pass in the arguments.
We will use default values for the remainder of the arguments
to the \code{MizerParams()} method. These are given in Table~\ref{tab:other_params}.
This means that we only need to pass in two arguments to the constructor:

<<>>=
params <- MizerParams(params_data, interaction = inter)
@

Note that the first argument must be the species parameters data.frame.
The remaining arguments can be in any order but should be named.
If we didn't want to use default values for the other arguments we would pass
them in to the constructor by name. For example, if wanted our species size spectrum
to have 200 size bins instead of 100 (the default) we would use:

<<eval=FALSE>>=
params <- MizerParams(params_data, interaction = inter, no_w = 200)
@

The above command creates an object of class \class{MizerParams}. 
But what does that mean?
The method uses the parameters specified in the arguments
and the default values to implement some of the equations described in 
Section~\ref{sec:principles} and calculate parameters for the model. 

As mentioned above, an object of class
\class{MizerParams} stores a wide range of model parameters. This 
information is held in what are known as 'slots'.  A description
of these slots can be found by calling \code{help()} on the class:

<<eval=FALSE>>=
help("MizerParams-class")
@

A list of the slots can also be seen using the \code{slotNames()} method.
The different slots can be accessed using the \code{@} operator.
For example, to look at the search volume slot, \code{search\_vol}
you enter:

<<results=hide>>=
params@search_vol
@

(the results are not shown here as the array is pretty huge)

The slot $species\_params$ contains the species parameters data.frame
that was passed in to the constructor. Now it also contains
any default values (for example, $alpha$) that may not have been
included in the original data.frame.

Also note how the default fishing gears have been set up.
Because we did not specify gear names in the original species parameter
data.frame, each species is fished by a unique gear named after the species.
This can be seen in the new $gear$ column which holds the names of the
fishing gears.
Also, the selectivity function for each fishing gear has been set in the
$sel\_func$ column (function \code{sigmoid\_length()}).

<<>>=
params@species_params
@

Note also that the species parameter data.frame we passed in to make to the
\code{MizerParams} did not have a \code{catchability} column.
Because of this, the \code{MizerParams()} constructor sets the catchability
for each gear to 1 for each of the species it catches.

In this case, each species is only caught by one gear.
An example of setting the catchability by hand can be seen in
Section\ref{sec:north_sea_example}.

There is a \code{summary()} method for \class{MizerParams} objects
which prints a useful summary of the model parameters:

<<results=hide>>=
summary(params)
@

\subsection{Setting different gears}

In the above example, each species is caught by a different gear (named
after the species it catches). This is the default when there is no $gear$
column in the species parameter data.frame.

Here, we look at an example where we do specify the fishing gears.
We take the original $params\_data$ species parameter data.frame
that was read in above and
bind an additional column, $gear$, to it. This $gear$ column 
contains the name of the gear that catches the species in that row.
Here we set up four different gears: Industrial, Pelagic, Beam Trawl
and Otter Trawl, that catch different combinations of species.

<<>>=
params_data$gear <- c("Industrial","Industrial","Industrial",
		      "Pelagic","Beam Trawl","Otter Trawl",
		      "Beam Trawl","Otter Trawl","Beam Trawl",
		      "Otter Trawl","Otter Trawl","Otter Trawl")
@

If you inspect the \code{params\_data} object you will see a new column, $gear$, has been added to it.  
We then make a new \class{MizerParams} object as before:

<<>>=
params_gears <- MizerParams(params_data, interaction = inter)
@

You can see that the gears in the new \class{MizerParams} object have
been set correctly by examining the $catchability$ slot:
<<>>=
params_gears@catchability
@

A catchability of 0 means that a species is not caught by that gear.
As we didn't
include a \code{catchability} column in the species parameter data.frame
the catchabilities have been set to the default value of 1.

In this example the same gear now catches multiple stocks. For
example, the 'Industrial' gear catches Sprat, Sandeel and Norway Pout.
Why would we want to set up the gears like this?
In the next section we will see that to project the model through time
you need to specify the fishing effort for each gear through time.
By setting the gears up in this way you can run different management
scenarios of changing the efforts of the fishing gears rather than on
individual species.
It also means that after a simulation has been run you can examine
the catches by gear.

\section{Running a simulation}
\label{sec:projection}

In \pkg{mizer} simulations are performed using the \code{project()}
method. This method takes a \class{MizerParams} object and projects it
forward through time, starting from an initital population abundance
and with a pre-determined fishing effort pattern.

Running a projection with \code{project()} requires various arguments:
\begin{description}
    \item[A \class{MizerParams} object] The model parameters (see previous
	section);
    \item[Fishing effort] The fishing effort of each gear through time;
    \item[Initial population] The initial abundances of the stocks and the
	background spectrum;
    \item[Time arguments] Arguments to control the time of the simulation,
	including the simulation time step, the length of the simulation
	and how frequently the output is stored.
\end{description}

The help page for \code{project()} describes the arguments in more detail.

The \class{MizerParams} class was explored in the previous section.
In this section we will look at the other arguments and use examples
to perform some simple projections.

\subsection{The time arguments}
\label{sec:time_arguments}

There are three arguments that control the \code{project()} method:
$dt$, $t\_max$ and $t\_save$.

$dt$ is the time step used by the numerical solver in \code{project()}.
This is the time step on which the model operates.
$t\_max$ determines the maximum time of the simulation, i.e. how long
the projection is run for. Note that
this is not necessarily the same as the number of time steps in the model.
The number of time steps in the model is given by $t\_max$ / $dt$.
For example, a simulation with $dt$ = 0.5 and $t\_max$ = 10 will perform
20 time steps.
The default values for $dt$ and $t\_max$ are 1 and 100 respectively.
The final argument is $t\_save$. This sets how frequently 
\code{project()} stores the state of the model in the \class{MizerSim}
object. For example, if $t\_save$ = 2, the state of the model is stored
at t = 0, 2, 4... etc.
$t\_save$ must be a multiple of $dt$. The default value of $t\_save$ is 1.

\subsection{Setting the fishing effort}

The fishing effort argument describes the effort of the fishing gears
in the model through time. Information on the fishing gears and their
selectivities and catchabilities is stored in the \code{MizerParams} argument.

There are three ways of setting the fishing effort. Examples of all three
can be seen in Section~\ref{sec:projection_examples}.

The simplest way is by passing the $effort$ argument as a single number.
This value is then
used as the fishing effort by all of the gears at each time step of the projection,
i.e. fishing effort is constant throughout the simulation and is the same for
all gears. The length of the simulation is determined by the $t\_max$
argument (see Section~\ref{sec:time_arguments}).

Another way of setting the fishing effort is to use a numeric vector
that has the same length as the number of gears.
The values in the vector are used as the fishing effort of each gear
at each time step, i.e. again, the fishing effort is constant
through time but each gear can have a different constant effort.
The order of values in the effort vector must be the same as the order
of gears in the \code{MizerParams} object 
(it may be helpful to name the effort vector after the gears but these names will not actually be used in \code{project()}). 
Again, the length of the simulation is determined by the $t\_max$ argument.

Finally, the most sophisticated way of setting the fishing effort is to
use a two-dimensional array or matrix of values, set up as time step by gear.
Each row of the array has the effort values of each fishing gear
at a time step (the time step is set by the argument $dt$, see above).
This means that it is not necessary to supply a $t\_max$ argument in
this case because the maximum time of the simulation is calculated by the
number of the time steps in the effort array (the first dimension) and
the value of $dt$. If a value for $t\_max$ is also supplied it is ignored.

\subsection{Setting the initial population abundance}

When running a simulation with the \code{project()} method,
the initial populations of the species and the background spectrum
need to be specified. These are passed to \code{project()} as the arguments 
$initial\_n$ and $initial\_n\_pp$ respectively.  $initial\_n$ is a matrix
(with dimensions species x size) that contains the initial
abundances of each species at size (the sizes must match those in the species
size spectrum). $initial\_n\_pp$ is a vector of the same length as the
the length of the full spectrum.

By default, the $initial\_n$ argument has values
calculated using the methods described in NORTH SEA PAPER.
These are implemented in the function \code{getInitialN()}.
The default value for $initial\_n\_pp$ is the carrying capacity
of the background spectrum, stored in the $cc\_pp$ slot of the
\class{MizerParams} parameters object.

\subsection{What do you get from running \code{project()}?}

Running \code{project()} returns an object of type \class{MizerSim}.
Like the \class{MizerParams} class this has various slots that contain the
output of the simulations.
An object of \class{MizerSim} has four slots, details of which can be seen
in the help page.
The $params$ slot holds the \class{MizerParams} object that was passed
in to \code{project()}.
The $effort$ slot holds the fishing effort of each gear through time.
Note that the $effort$ slot may not be exactly the same as the one passed in
as the $effort$ argument. This is because only the saved effort
 is stored (the frequency of saving is determined by the argument $t\_save$).
The $n$ and $n\_pp$ hold the saved abundances of the species and the
background population at size respectively. 
Note that The $n$ and $n\_pp$ slots have one more row than the $effort$ slot.
This is to the store the initial populations.

\subsection{Projection examples}
\label{sec:projection_examples}

In this section we'll look at how to run simulations with the \code{project()}
method whilst specifying fishing effort in different ways.
We will use the $params\_gears$ object with four gears that was created in the
\class{MizerParams} example above.

\subsubsection{Projections with simple constant effort}
In this first example we will use constant effort through time
for each of the fishing gears and this effort will be used for
all the gears. This means we only need to specify the $effort$ argument
as a single numeric.
As well as thinking about the $effort$ argument we also need to consider
the time parameters.
We will project the populations forward until time equals 10 ($t\_max$ = 10),
with a time step of 1 ($dt$ = 1), saving the output every time step 
($t\_save$ = 1).

<<>>=
sim <- project(params_gears, effort = 1, t_max = 10, dt = 1, t_save = 1)
@

The resulting $sim$ object is of class \class{MizerSim}.
The species abundances at size through time can be seen in the $n$ slot.
This is a three-dimensional array (time x species x size).
Consequently, this array can get very big so inspecting it can be difficult.
A range of summary methods and plots are available to make this job easier.
We will look at those in Section~\ref{sec:exploring}.
In the example we have just run the time dimension of the $n$ slot has 11
rows (one for the initial population and then one for each of 10 
saved time steps). There are also 12 species each with 100 sizes.
We can check this by running the \code{dim()} function and looking at
the dimensions of the $n$ array:

<<>>=
dim(sim@n)
@

To pull out the abundances of a particular species through time at size
you can subset the array. For example to look at Cod through time you
can use:

<<results=hide>>=
sim@n[,"Cod",]
@

The effort through time can be inspected by looking at the $effort$
slot (we use the \code{head()} function to just show the
first few lines).
In this example, we specified the $effort$ argument as a single numeric
of value 1. As you can see this results in the same effort being used for all
gears for all time steps:

<<>>=
head(sim@effort)
@

A \code{summary()} method is also available for objects of type \class{MizerSim}.

<<summary_mizersim,eval=FALSE>>=
summary(sim)
@

If we decrease $dt$ and $t\_save$ but keep $t\_max$ the same then
we can see that the time dimension of the $effort$ slot changes accordingly.
Now the model time step is 0.5 and we store the output at multiples of time = 0.5.
This will also be true of the $n$ and $n\_pp$ slots.

<<>>=
sim <- project(params_gears, effort = 1, t_max = 10, dt = 0.5, t_save = 0.5)
head(sim@effort)
@

As mentioned above, we can also set the effort values for each gear
seperatley using a vector of effort values. This still keeps the efforts
constant through time but it means that each gear can have a different
constant effort.

For example, if we want to switch off the industrial gear (i.e. effort = 0),
keep the pelagic gear effort at 1, and set the effort of both the trawl
gears at 0.5 we set the effort for each gear using a single effort vector,
where the positions of elements in the vector match the position of
the gears:

<<>>=
effort <- c(0,1,0.5,0.5)
@

We then call \code{project()} with this effort and inspect the resulting
$effort$ slot (again we use the \code{head()} function to just show the
first few lines):

<<>>=
sim <- project(params_gears, effort = effort, t_max = 10, dt = 1, t_save = 1)
head(sim@effort)
@

\subsubsection{An example of changing effort through time}

In this example we set up a more complicated fishing effort
structure that allows the fishing effort of each gear to change
through time.
As mentioned above, to do this effort must be supplied as a two dimensional
array or matrix. The first dimension is time step (determined by the
$dt$ argument) and the second dimension is gear.
Also, as mentioned above, if effort is passed in as an array or matrix
then the length of the simulation is determined by the
number of rows in the effort array and $dt$; the argument $t\_max$ is not used.
In our example $params\_gears$ object we have 
\Sexpr{length(unique(params_gears@species_params$gear))}
gears.

In this example, the effort of the industrial gear is held constant at 0.5,
the effort of the pelagic gear is increased linearly from 1 to 2, the effort
of the beam trawl decreases linearly from 1 to 0, whilst the effort of
the otter trawl decreases linearly from 1 to 0.5.
The final dimension of the array is 10 by 4.

<<>>=
effort_array <- cbind(rep(0.5,10),
    seq(from = 1, to = 2, length = 10),
    seq(from = 1, to = 0, length = 10),
    seq(from = 1, to = 0.5, length = 10))
@

The first few rows of the effort array are shown as an illustration:
<<>>=
head(effort_array)
@

The effort array does not need to have dimension names because it
is the order of the columns that is important, not their name.
The order of the columns must match the order of the gears in the
\class{MizerParams} object. 
As you can see in the previous examples, the dimensions of the effort
array do get named when it is processed by \code{project()}.

<<>>=
sim <- project(params_gears,effort=effort_array, dt=1, t_save = 1)
head(sim@effort)
@

It can be quite fiddly to set up a complicated effort array so it may
be easier to prepare it in advance as a .csv file and read it in,
similar to how
we read in the interaction matrix in Section~\ref{sec:params_example}.
We give an example of this in Section~\ref{sec:north_sea_example}.

\section{Exploring the simulation results}
\label{sec:exploring}

In the previous sections we saw how to set up a model and project it
forward through time under our desired fishing scenario.
The result of running a projection is an object of class \class{MizerSim}.
What do we then do?  How can we explore the results of the simulation?
In this section we introduce a range of summaries, plots and indicators
that can be easily produced using methods included in \pkg{mizer}.

\subsection{Summary methods for \class{MizerSim} objects}
\label{sec:summaries}

As well as the \code{summary()} methods that are available for both
\class{MizerParams} and \class{MizerSim} objects, there are some
useful summary methods to pull information out of
a \class{MizerSim} object (see Table~\ref{tab:summary_methods}).
All of these methods have help files to explain how they are used.

(It is also possible to use most of these methods with a \class{MizerParams}
object if you also supply the population abundance as an argument.
This can be useful for exploring how changes in parameter value or abundance
can affect summary statistics and indicators.
We won't explore this here but you can see their help files for more details.)

\begin{table}[ht]
    \begin{center}
	\begin{tabularx}{\linewidth}{r|X|X}
	\hline
	Method & Returns & Description \\
	\hline
	getSSB() & Two dimensional array (time x species) & Total Spawning Stock Biomass (SSB) of each species through time where SSB is calculated as EQUATION.\\
	getBiomass() & Two dimensional array (time x species) & Total biomass of each species through time.\\
	getN() & Two dimensional array (time x species) & Total abundance of each species through time.\\
	%getPhiPrey() & & \\
	getFeedingLevel() & Three dimensional array (time x species x size) & Feeding level of each species by size through time. \\
	%getPredRate() & &\\
	%getM2() & & \\
	getFMort() & Three dimensional array (time x species x size) & Total fishing mortality on each species by size through time.\\
	getFMortGear() & Four dimensional array (time x gear x species x size) & Fishing mortality on each species by each gear at size through time.\\
	%getZ() & & \\
	%getRDI & & \\
	%getRDD & & \\ % Need to add these
	getYieldGear() & Three dimensional array (time x gear x species) & Total yield by gear and species through time. \\
	getYield() & Two dimensional array (time x species) & Total yield of each species across all gears through time. \\
	\hline
	\end{tabularx}
	\caption{Summary methods for \class{MizerSim} objects.}
	\label{tab:summary_methods}
    \end{center}
\end{table}

%size_range
%Biomass
%N

The methods \code{getBiomass()} and \code{getN()} have additional arguments
that allow the user to set the size range over which to calculate the 
summary statistic.
This is done by passing in a combination of the arguments \code{min\_l}, 
\code{min\_w}, \code{max\_l} and \code{max\_w} for the minimum and maximum length or weight.
If \code{min\_l} is specified there is no need to specify \code{min\_w} and
so on. However, if a length is specified (minimum or maximum) then it is
necessary for the species parameter data.frame (see
Section~\ref{sec:species_parameters_dataframe}) to include the parameters
$a$ and $b$ for length-weight conversion.
It is possible to mix length and weight constraints, e.g. by supplying
a minimum weight and a maximum length.
The default values are the minimum and maximum weights of the spectrum.

\subsubsection{Examples of using the summary methods}
\label{sec:summaries_example}

Here we show a simple demonstration of using a summary method.
We first create a \class{MizerSim} object by projecting the parameters
set up earlier through time. We then use \code{getSSB()} to calculate the
SSB of each species through time.

<<>>=
sim <- project(params,effort=0.5, t_max = 10, dt=1, t_save = 1)
ssb <- getSSB(sim)
head(ssb)
@

As you can see, \code{getSSB()} calculates the SSB for each species though time. The time dimension depends on the value of the argument $t_save$ when \code{project()} was run.

As mentioned above, we can specify the size range of some of the methods.
For example, here we calculate the total biomass of each species but only
include individuals that are longer than 10 cm and shorter than 50 cm.

<<>>=
biomass <- getBiomass(sim, min_l = 10, max_l = 50)
head(biomass)
@

\subsection{Methods for calculating indicators}

Methods have been set up to calculate a range of indicators from a
\class{MizerSim} object after a projection. These
can be seen in Table~\ref{tab:indicator_methods}.
You can read the help pages for each of the methods for full instructions
on how to use them, along with examples.

With all of the methods in the table it is possible to specify the size
range of the community to be used in the calculation (e.g. to exclude very
small or very large individuals) so that the calculated metrics can be
compared to empirical data.
This is used in the same way that we saw with the method
\code{getBiomass()} in Section~\ref{sec:summaries}.
It is also possible to specify which species to include in the calculation.
See the help files for more details.

\begin{table}[ht]
    \begin{center}
	\begin{tabularx}{\linewidth}{r|X|X}
	\hline
	Method & Returns & Description \\
	\hline
	getProportionOfLargeFish() & A vector with values at each time step. & Calculates the proportion of large fish through time. The threshold value can be specified. It is possible to calculation the proportion of large fish based on either length or weight. \\
	getMeanWeight() & A vector with values at each saved time step.  & The mean weight of the community through time. This is calculated as the total biomass of the community divided by the total abundance.\\
	getMeanMaxWeight() & Depends on the $measure$ argument. If $measure$ == $both$ then you get a matrix with two columns, one with values by numbers, the other with values by biomass at each saved time step. If $measure$ = $numbers$ or $biomass$ you get a vector of the respective values at each saved time step. & The mean maximum weight of the community through time. This can be calculated by numbers or by biomass. See the help file for more details.\\
	getCommunitySlope() & A data.frame with four columns: time step, slope, intercept and $R^2$ value. & Calculates the slope of the community abundance spectrum through time by performing a linear regression on the logged total numerical abundance and logged body size. \\
	\hline
	\end{tabularx}
	\caption{Indicator methods for \class{MizerSim} objects.}
	\label{tab:indicator_methods}
    \end{center}
\end{table}

\subsubsection{Examples of calculating indicators}
\label{sec:indicators_example}

Here we show a simple demonstration of using indicator methods.
We first create a \class{MizerSim} object by projecting the parameters
set up earlier through time. 

<<>>=
sim <- project(params,effort=0.5, t_max = 10, dt=1, t_save = 1)
@

The slope of the community can be calculated using the 
\code{getCommunitySlope()} method. Initially we include all species and
all sizes in the calculation (only the first five rows are shown):

<<>>=
slope <- getCommunitySlope(sim)
head(slope)
@

See the help file for \code{getCommunitySlope} for an explanation of what the columns are.

We can include only the species we want with the $species$ argument.
Here we only include demersal species.
We also restrict the size range of the community that is used in the
calculation to between 10 g and 5 kg.

<<>>=
dem_species <- c("Dab","Whiting","Sole","Gurnard","Plaice","Haddock",
    "Cod","Saithe")
slope <- getCommunitySlope(sim, min_w = 10, max_w = 5000, 
    species = dem_species)
head(slope)
@

\subsection{Plotting the results}

\R is very powerful when it comes to exploring data through plots.
A useful package for plotting is \pkg{ggplot2}.
\pkg{ggplot2} uses data.frames for input data. Many of the summary
methods and slots of the \pkg{mizer} classes are arrays or matrices.
Fortunately it is straightforward to turn arrays and matrices into
data.frames using the command \code{melt} which is in the \pkg{reshape}
package.
It is probably worth your time getting to grips with these packages to make
plotting easier.

%PERHAPS INCLUDE EXAMPLE OF USING GGPLOT WITH MIZER BELOW?

Included in \pkg{mizer} are several dedicated plots that use
\class{MizerSim} objects as inputs (see Table~\ref{tab:plots}).
As well as displaying the plots, these methods all return objects of
type \class{ggplot} from the \pkg{ggplot2} package.
See the help page of the individual plot methods for more details.
The generic \code{plot()} method has also been overloaded for
\class{MizerSim} objects. This produces several plots in the same window
to provide a snapshot of the results of the simulation.

Some of the plots plot values by size (for example \code{plotFeedingLevel()}
and \code{plotSpectra()}).
For these plots, the default is to use the data at the final time
step of the projection.
With these plotting methods, it is also possible to specify a different time
step to plot or a time range to average the values over before plotting. 

\begin{table}[ht]
    \begin{center}
	\begin{tabularx}{\linewidth}{r|X}
	\hline
	Plot & Description \\
	\hline
	plotBiomass() & Plots the total biomass of each species through time. The size range of the community can be specified in the same way as the method \code{getBiomass()}.\\
	plotSpectra() & Plots the abundance (biomass or numbers) spectra of each species and the background community. It is possible to specify a minimum size which is useful for truncating the plot. \\
	plotFeedingLevel() & Plots the feeding level of each species against size.\\
	plotM2() & Plots the predation mortality of each species against size.\\
	plotFMort() & Plots the total fishing mortality of each species against size.\\
	plotYield() & Plots the total yield of each species across all fishing gears against time.\\
	plotYieldGear() & Plots the total yield of each specis by gear against time.\\
	plot() & Produces 5 plots (\code{plotFeedingLevel()}, \code{plotBiomass()}, \code{plotM2()}, \code{plotFMort()} and \code{plotSpectra()}) in the same window as a summary.\\
	\hline
	\end{tabularx}
	\caption{Plot methods for \class{MizerSim} objects.}
	\label{tab:plots}
    \end{center}
\end{table}

\subsubsection{Plotting examples}
\label{sec:plot_examples}

Using the plotting methods is straightforward.
For example, to plot the total biomass of each species against
time you use the \code{plotBiomass()} method:
<<eval=FALSE>>=
plotBiomass(sim)
@

The outcome of which can be seen in Figure~\ref{fig:plotBiomass_example}.
\begin{figure}
<<label=plotBiomass_example, fig=TRUE, echo=FALSE>>=
    p <- plotBiomass(sim)
    print(p)
@
\caption{An example of using the \code{plotBiomass()} method.}
\label{fig:plotBiomass_example}
\end{figure}

As mentioned above, some of the plot methods plot values against size
at a point in time (or averaged over a time period).
For these plots it is possible to specify the time step to plot,
or the time period to average the values over. The default is to use
the final time step.
Here we plot the abundance spectra (biomass), averaged over time = 5 to 10
(the simulation was projected until $t$ = 10; see
Figure~\ref{fig:plotSpectra_example}):

<<eval=FALSE>>=
plotSpectra(sim, time_range = 5:10, biomass=TRUE)
@

\begin{figure}
<<label=plotSpectra_example, fig=TRUE, echo=FALSE>>=
p <- plotSpectra(sim, time_range = 5:10, biomass=TRUE)
print(p)
@
\caption{An example of using the \code{plotSpectra()} method, plotting values averaged over the period $t$ = 5 to 10.}
\label{fig:plotSpectra_example}
\end{figure}

As mentioned above, the generic \code{plot()} method has also been
overloaded.% (see Figure~\ref{fig:plot_example}).
This produces 5 plots in the same window (\code{plotFeedingLevel()},
\code{plotBiomass()}, \code{plotM2()}, \code{plotFMort()} and
\code{plotSpectra()}). It is possible to pass in the same arguments that
these plots use, e.g. arguments to change the time period over which the
data is averaged.

<<eval=FALSE>>=
plot(sim)
@

%\begin{figure}
%<<label=plot_example, fig=TRUE, echo=FALSE>>=
%p <- plot(sim)
%@
%\caption{Example output from using the summary \code{plot()} method.}
%\label{fig:plot_example}
%\end{figure}


\section{A detailed example using the North Sea}
\label{sec:north_sea_example}

Here we give a detailed example of projecting a fishery through time
using historical levels of fishing effort.
We use data from the North Sea from 1957 to 2010 and compare the simulated
population trajectories to the best estimates of abundance from ICES where
available.

\subsection{Setting up the North Sea model}

As before, we load the species and interaction parameters for the North Sea.
Note that we are the using dataset without fishing gears because in
this example, we want to control the individual levels of effort on each
species. 

<<label = load_ns_species_params>>=
params_data <- read.csv("simple_species_params.csv")
inter <- as(read.csv("inter.csv", row.names=1),"matrix")
@

The historical fishing mortality from 1967 to 2010 for each species is stored
in the csv file \code{f\_history.csv}.
As before, we can use the \code{read.csv()} to read in the data. This
reads the data in as a \class{data.frame}. We want this to
be a \class{matrix} so we use the \code{as.matrix()} function:

<<label=load_f_history>>=
f_history <- as.matrix(read.csv("f_history.csv",row.names=1))
@

We can take a look at the first years of the data.
<<label=head_f_history>>=
head(f_history)
@

Note that the order of the species in the \code{f\_history} object is
the same as that in the species parameters data.frame.
This has to be the case.

As mentioned in Section~\ref{sec:fishing_gear}, fishing mortality is
calculated as a combination of
selectivity, catchability and fishing effort.
The values in \code{f\_history} are absolute levels of fishing mortality.
To use the \code{project()} method we need to provide a matrix of fishing
effort that will result in these historical fishing mortality levels.

One way of doing this is to set the catchability of all species to 1
and then use the \code{f\_history} matrix as the fishing effort.
However, it is probably clearer to use the effort relative to a
particular year.  Here we use the year 1990.
To do this we set the catchability of each species to be the same as
fishing mortality in 1990. 
This means that a relative effort of 1 in 1990 will result
in the fishing mortality being what it was in 1990.

The catchability can be set by either including a 'catchability' column
in the species parameters data.frame, or by manipulating the catchability
slot directly after the \class{MizerParams} object has been created.
Here we use the former method.

<<label=set_catchability>>=
params_data$catchability <- as.numeric(f_history["1990",])
@

We are going to use the default stock-recruitment function for each of the
species (see Section~\ref{sec:srr}).
This uses the parameter \code{r\_max} which means that we need
to set values of this parameter for all species.
This can be done by including an 'r\_max' column in the species
parameters data.frame.
These values are taken from NS PAPER REFERENCE. The values were found
through a calibration process which is not covered here but will be added to
a later version of this manual. 

<<label=set_r_max>>=
params_data$r_max <- c(5.43e11,3.65e11,1.51e12,4.40e12,3.34e11,
2.68e10,1.16e09,1.27e10,1.00e18,6.20e10, 5.26e08,1.65e10)
@

We can now create the \code{MizerParams} object using the species
parameters data.frame.

<<label=make_ns_params>>=
params <- MizerParams(params_data, inter)
@

Here we check that the catchability has been
set correctly by inspecting the diagonal of the catchability slot.
<<label=check_catchability>>=
diag(params@catchability)
@

Now we can make the matrix of relative effort through time that will
be used with the \code{project()} method.
To do this we want rescale the \code{f\_history} object to 1990 so that
the relative effort in 1990 = 1.
We then check a few rows of the effort matrix to check this has happened:

<<label=rescale_effort>>=
effort <- sweep(f_history,2,f_history["1990",],"/")
effort[as.character(1988:1992),]
@

We could just project forward with these relative efforts. However,
the population dynamics in the early years will be strongly
determined by the initial population abundances (known as the transient
behaviour - essentially the initial behaviour before the long term dynamics
are reached).
As this is fisheries science, we don't know what the initial abundance are.
One way around is this to project forward at a constant fishing effort
equal to the first year of historical relative effort until equilibrium
is reached.
We then can carry on projecting forward using the remaining years of effort.
This approach reduces the impact of transient dynamics.

Here we make an inital effort matrix of 100 years at the first effort level,
and then stick it on top of the original matrix of historical relative
effort:

<<>>=
initial_effort <- matrix(effort[1,],byrow=TRUE, nrow=100,ncol=ncol(effort))
effort <- rbind(initial_effort,effort)
@

\subsection{Running the simulation}

We now have our parameter object and out matrix of efforts relative to 1990.
This includes an initial 100 years of constant relative effort at the
1957 level, followed by the relative effort from 1957 to 2010
We can use this effort matrix as an argument to the \code{project()} method.
We use \code{dt} = 1 and save the results every year.

<<>>=
sim <- project(params, effort=effort, dt = 1, t_save = 1)
@

Plotting the results, we can see how the biomasses of the stocks change
over time (Figure~\ref{fig:plot_ns_biomass}).
You can see the 100 year period of transients with constant fishing effort
as the dynamics approach equilibrium before the historical
relative effort is used.


<<eval=FALSE>>=
plotBiomass(sim)
@

\begin{figure}
<<label=plot_ns_biomass, fig=TRUE, echo=FALSE>>=
p <- plotBiomass(sim)
print(p)
@
\caption{Simulated biomasses of stocks in the North Sea with 100 years of transients.}
\label{fig:plot_ns_biomass}
\end{figure}



Compare outputs to ICES data.

Bring in some bits from NS PAPER

%\section{Under the hood of \pkg{mizer}: notes for developers}
%
%Still to come.
%
%Classes and whatnot



\section{Acknowledgements}

The authors of the \pkg{mizer} package would like to thank the authors
of the \pkg{abc} package for allowing them to use some of the introductory
text from their vignette.

Finlay Scott would like to thank the Cefas Seedcorn Project DP266
and the Defra project MF1225 for supporting this work.

%-------------------------------------------------------------------------
% References
%------------------------------------------------------------------------

\bibliography{reflib}{}
%\bibliographystyle{plain}
\bibliographystyle{plainnat}

\end{document}

