% place *.rnw inside mizer/vignettes
% RCMD build mizer
% To make the tar ball which includes the compiled pdf
% RCMD INSTALL --build mizer.tar.gz****
% To make the windows binary from the tarball. This binary zip file contains the vignette in pdf form
% In R, load the library then
% vignette("mizer_vignette") to open the vignette


% For checking the latex works OK
% setwd("~/Work/size_based_modelling/mizer/vignettes")
% Sweave("mizer_vignette.Rnw", syntax="SweaveSyntaxNoweb")
% shell("pdflatex mizer_vignette.tex")
%
% shell("bibtex mizer_vignette")


\documentclass{article}
\setlength{\parindent}{0pt}	% Eliminate the indent at the beginning of a new paragraph
%\setcounter{secnumdepth}{0}	% Elimate the section numbering starting from a specific depth (see WikiBook)
\setcounter{secnumdepth}{3}	% Elimate the section numbering starting from a specific depth (see WikiBook)
\usepackage[round,sort]{natbib} 
\usepackage{fixltx2e}
\usepackage{graphicx}	% To manage external pictures
\usepackage{float}
\usepackage{subfig}	% To add subfigures within figures, with labels (see WikiBooks)
\usepackage{tabularx}
\usepackage{verbatim}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\usepackage{amssymb,amsbsy,amsmath}
\usepackage{epsfig}
\usepackage[left=3cm,top=3cm,bottom=3.5cm,right=3cm]{geometry}	% For easy management of document margins
\usepackage{fancyhdr} % To customize the header/footer (see WikiBooks)
\usepackage{rotating}
\usepackage{authblk}
\numberwithin{equation}{section}	% Equation numbers relative to sections

%% Set PDF 1.5 and compression, including object compression
%% Needed for MiKTeX -- most other distributions default to this
\ifx\pdfoutput\undefined
\else
  \ifx\pdfoutput\relax
  \else
    \ifnum\pdfoutput>0
      % PDF output
      \pdfminorversion=5
      \pdfcompresslevel=9
      \pdfobjcompresslevel=2
    \fi
  \fi
\fi

% ---------------------------------------------------------------------------------------------------------------------------------------

%\VignetteIndexEntry{Introduction to mizer}
%\VignettePackage{mizer}
%\documentclass{amsart}
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\pkg}[1]{{\texttt{#1}}}
\newcommand{\class}[1]{{\textit{#1}}}
\newcommand{\R}{{\normalfont\textsf{R }}{}}

\begin{document}

% This stuff came from abc vignette
% <<label=R options,echo=FALSE>>=
% options(width = 60)
% options(SweaveHooks = list(fig = function() par(mar=c(3,3,1,0.5),mgp = c(2,1,0))))
% @

%\SweaveOpts{prefix.string=fig,include=F,keep.source=T,eps=FALSE}

% <<echo=false>>=
% options(continue="  ")
% @
% %@% TO ELIMINATE THE "+" IN CONSECUTIVE SCRIPT LINES

\title{Multi-species size-based ecological modelling in \R (\pkg{mizer}): An introductory vignette}
%\author{F. Scott, J. Blanchard, K. H. Andersen}
\author[*]{F. Scott}
\author[**]{J. Blanchard}
\author[***]{K. H. Andersen}
\affil[*]{Cefas, Lowestoft, UK}
\affil[**]{University of Sheffield, UK}
\affil[***]{DTU Aqua, Copenhagen, DK}
\renewcommand\Authands{ and }
\date{\pkg{mizer} version \Sexpr{packageDescription("mizer")[["Version"]]} , \Sexpr{Sys.Date()} }
\maketitle

\tableofcontents
\setcounter{footnote}{1} \footnotetext{This document is included as a
  vignette (a \LaTeX\ document created using the \R function
  \code{Sweave}) of the package \pkg{mizer}. It is automatically
  dowloaded together with the package and can be accessed through \R
  typing \code{vignette("mizer\_vignette")}.}  \newpage
\setlength{\parskip}{4pt} % Space between paragraphs

<<echo=FALSE>>=
rm(list=ls())
@ 
%-----------------------------------------------------------------------------------
\section{Summary}
Size-based ecological models have emerged as a conceptually simple way to model a large community of individuals which grow and change trophic level during their lives. They are a subset of physiologically structured models where growth (and thus maturation) is food dependent, and processes are formulated in terms of individual level processes.
A key feature of size-based ecological is that of a \emph{size spectrum}, where the total abundance of individuals at size scales negatively with size: there are more small things than big things.

\pkg{mizer} is a software package for implementing size-based ecological models using the \R statistical programming environment.
The package has been developed to model marine ecosystems that are subject to fishing.

Roughly speaking there are three versions of the size spectrum modelling framework of increasing complexity: The \emph{community} size spectrum model, in which only one ''species'' is resolved; 
the \emph{trait-based} size spectrum model, in which all the species-specific parameters are the same, except for the asymptotic size which determines other life-history parameters such as the size at maturity;
and the \emph{food-web} spectrum model in which multiple ''real'' species are resolved, each of which can have differing species-specific traits. 
The community and trait-based models can be considered as simplifications of the food-web type model and \pkg{mizer} is able implement all three versions, using the same set of tools.

\pkg{mizer} contains routines and methods to allow users to set up the model community, and then project it through time under different fishing strategies.
The results of the simulations can be then explored using a range of plots and summary methods, including plots of community size spectra and the calculation of community indicators such as the slope of the size spectrum.

The models created using \pkg{mizer} can be quite flexible and there are many options for setting up and running simulations.  For example, different stock-recruitment relationships for the species can be implemented and fishing gears with different selectivity patterns can be set up so that different species are caught by different gears.

However, \pkg{mizer} aims to make setting up size-based models relatively simple.  For example, easy to use ''wrapper'' functions are provided so users can easily set up community and trait-based models which are based on a specific set of assumptions.  Additionally, most of the methods and functions in the package have default options and assumptions that can be easily changed by the user once they are familiar with the models 

This vignette starts by summarising the principles and assumptions of size-based models. The \pkg{mizer} package is then introduced by showing how to set up the simplest types of size-based models, the community and trait-based model. This gives a basic overview of the structure of the classes and methods used by \pkg{mizer}. Simple examples are given by demonstrating how a trophic-cascade can be simulated. There then follows a more detailed description of the \pkg{mizer} classes and methods using a food-web model of the North Sea as an example. Finally, there is a detailed example of a size-based model of the North Sea, including a recreation of historical fishing patterns and biomasses.

%-------------------------------------------------------------------------------
\section{Package installation and R}

\subsection{Installing \pkg{mizer}}

\pkg{mizer} is a package for the \R open-source statistical programming language. \R is available from the CRAN website, which is also an excellent source of documentation and tutorials.

The easiest way to install \pkg{mizer} (assuming you have an active internet connection) is to start an \R session and then type:

<<eval=FALSE>>=
install.packages("mizer")
@

After installing \pkg{mizer}, to actually use it you need to load the package using the \code{library()} function. Note that whilst you only need to install the package once, it will need to be loaded everytime you start a new \R session.
<<results = hide>>=
library(mizer)
@

The source code for \pkg{mizer} is currently hosted at Github (\url{https://github.com/drfinlayscott/mizer}). If you are feeling brave and wish to try out a development version of \pkg{mizer} you can install the package from here, using the library \pkg{devtools} (which was used extensively in putting together \pkg{mizer}).

\subsection{Getting help}

As you probably know, to access documention \R you use the \code{help()} function. This can use to access help in a range of ways. For example:

<<label=help_demo, eval=FALSE>>=
help(package="mizer")
help(mizer)
help(project)
@

The first command gives a technical summary of the package, including the available functions.
The second command gives a brief introduction to \pkg{mizer}.
The third gives the documentation page for the function \code{project()}.

Some methods are associated with several \R classes. For example, the \code{plot()} method is generic and can be used on a wide range on objects in \R.
To select the help page for the appropriate plotting method you also need to supply the package name. For example, the \code{plot()} method is used in \pkg{mizer} to plot \class{MizerSim} objects. To see the help page you then use:

<<label=help_plot, eval=FALSE>>=
help(plot, package="mizer")
@

%----------------------------------------------------------------------------------
\section{Introduction to size-based modelling - assumptions, concepts and processes}
\label{sec:principles}

Size spectrum models have emerged as a conceptually simple way to model a large community of individuals which grow and change trophic level during life.
There is now a growing literature describing different types of size spectrum models
\citep{benoit_continuous_2004, andersen_asymptotic_2006, andersen_life-history_2008, law_size-spectra_2009, hartvig_food_2011, hartvig_food_2011-1}
and their application, mostly in a marine context, to understand how marine communities are organised
\citep{andersen_asymptotic_2006, andersen_trophic_2009,blanchard_how_2009} and how they respond to fishing \citep{andersen_direct_2010, andersen_damped_2010}. This section introduces the central assumptions, concepts, processes, equations and parameters of a size-based model.

Roughly speaking there are three versions of the size spectrum modelling framework of increasing complexity: The \emph{community} size spectrum model
\citep{benoit_continuous_2004, maury_modeling_2007,blanchard_how_2009,law_size-spectra_2009}, the \emph{trait-based} size spectrum model \citep{andersen_asymptotic_2006, andersen_damped_2010}, and the \emph{food-web} spectrum model \citep{hartvig_food_2011-1}. The focus of this section is on the food-web type of model where each species is characterized by its own set of parameters. The community and trait-based models can be considered as simplifications of the food-web type model and hence \pkg{mizer} is able implement all three versions.


\subsection{Central concepts and assumptions}
Size spectrum models are a subset of physiologically structured models \citep{metz_dynamics_1986,de_roos_physiologically_2001} as growth (and thus maturation) is food dependent, and processes are formulated in terms of individual level processes.  All parameters in the size spectrum models are related to individual weight which makes it possible to formulate the model with a small set of general parameters (Table~\ref{tab:parameters}), which has prompted the label ``charmingly simple'' to the model framework \citep{pope_modelling_2006}.

The model framework builds on two central assumption and a number of lesser standard assumption.  

The first central assumption is that an individual can be characterized by its weight $w$ and its species number $i$ only. The aim of the model is to calculate the size- and trait-spectrum ${\cal N}_i(w)$ which is the density of individuals such that ${\cal N}_i(w)dw$ is the number of individuals in the interval $[w:w+dw]$. The dimensions of the size spectrum are numbers per weight per volume.  Scaling from individual-level processes of growth and mortality to the size spectrum of each trait group is achieved by means of the McKendrik-von Foerster equation, which is simply a conservation equation:

\begin{equation}
  \label{eq:MvF}
  \frac{\partial N_i(w)}{\partial t} + \frac{\partial g_i(w) N_i(w)}{\partial w} = -\mu_i(w) N_i(w)
\end{equation}

where individual growth $g_i(w)$ and mortality $\mu_i(w)$ are both determined by the availability of food from the other species and a resource $N_R(w)$, and predation by the other species. The conservation equation is supplemented by a boundary condition at the right boundary at weight $w_0$ where the flux of individuals (numbers per time) $g_i(w_0) N_i(w_0)$ is determined by the reproduction of offspring by mature individuals in the population $R_i$:

\begin{equation}
  \label{eq:3}
  g_i(w_0)N_i(w_0) = R_i.
\end{equation}

The second central assumption is that the preference of food is determined by individual weight combined with a species preference. The preference for prey weight is described by the log-normal selection model \citep{ursin_prey_1973} which prescribes prey preference in terms of the ratio between the weight of predators $w$ and prey of weight $w_p$:

\begin{equation}
  \label{eq:4}
  \phi(w_p/w) = \exp \left[ \frac{-(\ln(w/(w_p \beta_i)))^2}{2\sigma_i^2} \right],
\end{equation}
where $\beta_i$ is the preferred predator-prey mass ratio and $\sigma_i$ the width of the weight selection function.

The rest of the formulation of the model rests on a number of ``standard'' assumptions from ecology and fisheries science about how encounters between predators and prey leads to growth $g_i(w)$ and recruitment $R_i$ of the predators, and mortality of the prey $\mu_i(w)$.

\subsection{Predator-prey encounter}
The encounter of food is based on the ``Andersen-Ursin'' encounter model which was developed as a part of the North-Sea ecosystem model \citep{andersen_multispecies_1977}, see also \citep{andersen_asymptotic_2006}.  

The available food (mass per volume) for a predator of weight $w$ is determined by integrating over all species and the resource weighted by the size selection function (\ref{eq:4}): 

\begin{equation}
  \label{eq:1}
  E_{a.i}(w) = \int \left( N_R(w) + \sum_{j} \theta_{ij} N_j(w) \right) \phi(w_p/w) w \, dw_p.
\end{equation}

where $\theta_{ij}$ is the preference of species $i$ for species $j$. The food actually encountered $E_{e.i}$ (mass per time) depends on the search rate (volume per time) which is assumed to scale with individual weight as $\gamma_i w^q$:

\begin{equation}
  \label{eq:Ee}
  E_{e.i}(w) = \gamma_i w^q E_{a.i}.
\end{equation}

\subsection{Consumption}
The encountered food is consumed subjected to a standard Holling functional response type II to represent satiation.  This determines the \emph{feeding level} $f_i(w)$ which is a dimensionless number between 0 (no food) and 1 (fully satiated):

\begin{equation}
  \label{eq:f}
  f_i(w) = \frac{E_{e.i}}{E_{e.i} + h_i w^n},
\end{equation}

where $h_i w^n$ is the maximum consumption rate.

\begin{figure}[t]
  \centering
 \includegraphics[width=0.8\textwidth]{Growth_curve.eps}
  \caption{The growth curve of an individual found by solving (\protect\ref{eq:growth}) with a constant feeding level $f_0 = 0.6$ (solid line), compared to a von Bertalanffy growth curve with the von Bertalanffy growth parameter $K = (\alpha f_0 h w^n - k_{s} w^n) W^{n-1}/3$ \protect\citep{andersen_how_2009} (dashed line).}
  \label{fig:growth}
\end{figure}


\subsection{Growth}
The consumed food $f_i(w) h_i w^n$ is assimilated by an efficiency $\alpha$ and used to fuel the needs for standard metabolism and activity $k_{s.i} w^p$. The remaining available energy, $\alpha f_i(w) h_i w^n - k_{s.i} w^p$, is divided between growth and reproduction by a function of weight changing between zero around the weight of maturation to one at the asymptotic weight where all available energy is used for reproduction:

\begin{equation}
  \label{eq:psi}
  \psi_i(w) = \left[ 1 + \left( \frac{w}{w_{m.i}} \right)^{-10} \right]^{-1} \left( \frac{w}{W_i} \right)^{1-n},
\end{equation}

where $w_{m.i}$ is the weight at maturation and $W_i$ is the asymptotic (maximum) size.  The term in the square bracket is a function which varies smoothly from 0 to 1 around the weight at maturation.  The last term describes how the relative amount of energy invested in reproduction increases as the weight approaches the asymptotic weight.  The somatic growth function therefore becomes:

\begin{equation}
  \label{eq:growth}
  g_i(w) = (\alpha f_i(w) h_i w^n - k_{s.i} w^p)(1-\psi(w)).
\end{equation}

The form of the allocation function (\ref{eq:psi}) is chosen such that the growth curve approximates a von Bertalanffy growth curve if the feeding level is constant (see \citep{hartvig_food_2011-1} for details about the derivation). The actual emerging growth curves from the model will depend on the feeding level, and may even result in stunted growth curves if the feeding level drops below the \emph{critical feeding level} where the assimilated food is just enough to satisfy standard metabolism:

\begin{equation}
  \label{eq:fc}
  f_{c.i}(w) = k_{s.i} w^n/(\alpha h_i) w^p.
\end{equation}

If $n=p$ (which is the case for the set of parameters chosen here), $f_c$ is independent of $w$.

\subsection{Reproduction}
The total production of eggs $R_{p.i}$ (numbers per time) is found by integrating the energy allocated to reproduction over all individuals:

\begin{equation}
  \label{eq:Rp}
  R_{p.i} = \frac{\epsilon}{2 w_0} \int N_i(w)  (\alpha f_i(w) h_i w^n - k_{s.i} w^p) \psi_i(w) \, dw,
\end{equation}

where $w_0$ is the egg weight, $\epsilon$ is the efficiency of reproduction, and the factor $1/2$ takes into account that only females reproduce.

\subsection{Recruitment}
\label{sec:recruitment}

\begin{figure}[t]
  \centering
  \includegraphics{recruitment.eps}
  \caption{The Beverton-Holt recruitment function (thick line) which determines the recruitment $R$ as a function of the egg production (the ``physiological recruitment'') $R_p$ via (\protect\ref{eq:R}).}
  \label{fig:recruitment}
\end{figure}

One of the fundamental assumptions in fisheries science is that marine fish populations experience a significant density dependence early in life  \citep{ricker_stock_1954}.  This assumption has some empirical backing for selected, well-studied stocks \citep{myers_density-dependent_1993} and is also supported by the general observation that marine fish do not experience strong food-dependent growth.  This is in contrast to fish in lakes where stunted growth is not uncommon. From a technical point of view, an additional density dependence is needed to stabilize the community to avoid some of the trait classes going extinct \citep{hartvig_food_2011}. An alternative way to ensure coexistence of many species is to introduce a random food web matrix describing species-specific food preference \citep{hartvig_food_2011-1} or an abstract notion of space \citep{hartvig_food_2011}.

In \pkg{mizer}, density dependence is modelled as a compensation on the egg production. This can be considered as the stock-recruitment relationship (SRR).
The default functional form is such that the recruitment flux $R_i$ (numbers per time) approaches a maximum recruitment as the egg production increases, modelled mathematically analogous to the Holling type II function response as a ``Beverton-Holt'' type of SRR:

\begin{equation}
  \label{eq:R}
  R_i = R_{\max.i} \frac{R_{p.i}}{R_{p.i} + R_{\max.i}},
\end{equation}
where $R_{\max.i}$ is the maximum recruitment flux of each trait class (Figure~\ref{fig:recruitment}). 

This requires the parameter $R_{\max.i}$ to be set for each species in the model.

The ''Beverton-Holt'' type of SRR is not the only density dependence model that \pkg{mizer} can use. Users are able to write their own model so it is possible to set a range of SRRs, e.g. fixed recruitment (as used in the community-type model) or ''hockey-stick''. This is explored in more detail in Section~\ref{sec:srr}.

\subsection{Mortality}
The mortality rate of an individual $\mu_i(w)$ has three sources: predation mortality $\mu_{p.i}(w)$ , starvation mortality $\mu_{s.i}(w)$, and a constant background mortality $\mu_{b.i}(w)$. The background mortality is needed to ensure that the largest individuals in the community also experience mortality as they are not predated upon by any individuals from the community spectrum.  Predation mortality is calculated such that all that is eaten translates into corresponding predation mortalities on the ingested prey individuals (see \citep[App.~A]{hartvig_food_2011-1} for derivation):

\begin{equation}
  \label{eq:mup}
  \mu_{p.i}(w_p) = \sum_j \int \phi(w_p/w) (1-f_i(w)) \gamma_j w^q \theta{ji} N_j(w) \, dw.
\end{equation}

When food supply does not cover metabolic requirements $k_{s.i} w^p$, growth stops, i.e.~no negative growth, and the individual is subjected to a starvation mortality.  Starvation mortality is assumed proportional to the energy deficiency $k_{s.i} w^p - \alpha f_i(w) h_i w^n$, and is inversely proportional to lipid reserves, which are assumed proportional to body weight:
\begin{equation}
  \label{eq:mu_s}
  \mu_{s.i}(w) = \left\{ \begin{array}{lc}
0 & \alpha f_i(w) h_i w^n > k_{s.i} w^p \\
 \frac{k_{s.i} w^p - \alpha f_i(w) h_i w^n}{\xi w} & \mathrm{otherwise}
\end{array} \right. .
\end{equation}

Starvation is usually not an important process in the food-web model with Beverton-Holt recruitment.

Mortality from other sources than predation and starvation is assumed constant within a species and inversely proportional to generation time \citep{peters_ecological_1986}:
\begin{equation}
  \label{eq:mu_b}
  \mu_{b.i} = \mu_0 W_i^{n-1}.
\end{equation}
The background mortality is needed to remove the largest individuals which do not experience predation mortality.

\subsection{Resource dynamics}
The resource spectrum $N_R(w)$ represents food items for the smallest individuals (smaller than $\beta w_0$). The temporal evolution of each size group in the resource spectrum is described using semi-chemostatic growth:
\begin{equation}
  \label{eq:nb}
  \frac{\partial N_R(w,t)}{\partial t} = r_0 w^{p-1} \Big[ \kappa_R w^{-\lambda} - N_R(w,t) \Big] - \mu_p(w) N_R(w,t),
\end{equation}
where $r_0 w^{p-1}$ is the population regeneration rate \citep{fenchel_intrinsic_1974,savage_effects_2004} and $\kappa_R w^{-\lambda} = \kappa_R w^{-2-q+n}$ the carrying capacity.

\begin{table}[t]
  \centering
  \caption{Parameters in the model with dimensions and ``default'' values. For a detailed explanation of the determination of the values see \protect\citep[App.~E]{hartvig_food_2011-1}.}
  \label{tab:parameters}
  \begin{tabular}{llllp{7cm}}
    %&  & Value & Units & Description \\
    \hline
    \multicolumn{5}{l}{ Resource spectrum} \\
    & $\kappa_R$ & $5\cdot{}10^{-3}$ & g$^{\lambda-1}/$m$^3$ & Magnitude of the resource spectrum \\
    & $\lambda$ & 2.05 & - & Exponent of resource spectrum ($=2-n+q$)\\
    & $r_0$ & 4 & g$^{1-p}$/yr & Constant for regeneration rate of resources \\
    & $w_{cut}$ & 0.5 & g & Upper weight limit of the resource spectrum \\
    \multicolumn{5}{l}{ Individual growth} \\
    & $f_0$ & 0.6 & - & Initial feeding level\\
    & $\alpha$ & 0.6 & - & Assimilation efficiency\\
    & $h$ & 40$^\dagger$ & $\mathrm{g}^{1-n}$/yr & Constant for max. food intake \\
    & $n$ & 0.75 & - & Exponent for max. food intake \\
    & $k_s$ & 4.8$^\dagger$ & g$^{1-p}/$yr & Constant for std. metabolism and activity \\
    & $p$ & 0.75 & - & Exponent of standard metabolism* \\
    & $\beta$ & 100 & - & Preferred predator-prey mass ratio \\
    & $\sigma$ & 1.3$^\P$ & - & Width of size selection function \\
    & $\gamma$ & Eq.~(\protect \ref{eq:gamma}) & g$^{-q}$/yr & Constant for volumetric search rate \\
    & $q$ & 0.8$^\S$ & - & Exponent for volumetric search rate \\
    \multicolumn{5}{l}{ Mortality} \\
    & $\xi$ & 0.1 & - & Fraction of body weight containing reserves \\
    & $\mu_0$ & 3$^\dagger$ & g$^{1-n}/$yr & Constant for background mortality \\
    \multicolumn{5}{l}{Reproduction and recruitment} \\
    & $w_0$ & 0.5 & mg & Offspring weight \\
%   & $\eta$ & 0.25 & - & Weight at maturation divided by  $W$  \\
    & $\epsilon$ & 0.1 & - & Efficiency of offspring production \\
    & $\kappa$ & 50$^\ddagger$ & - & Factor for maximum recruitment. \\
    \hline
    \multicolumn{5}{p{\textwidth}}{\footnotesize *Laboratory experiments on fish indicate that the exponent of standard metabolism should be higher, around $p=0.86$ \protect\citep{winberg_rate_1956,killen_little_2007}. The practical implication of choosing $p>n$ is that a maximum weight for individuals at which all energy, even if $f=1$, is used for standard metabolism at $W_+ = [ (\alpha h)/k_s ]^{1/(p-n)}$ \citep[Eq.~8]{andersen_life-history_2008}. Here a value of $p=n$ is used to make the analysis of the model output easier. }\\
\multicolumn{5}{p{\textwidth}}{\footnotesize $^\dagger$Adjusted to a different value than in \protect\citep{hartvig_food_2011-1} to give growth rates similar to growth rates of species in the North Sea. }\\
\multicolumn{5}{p{\textwidth}}{\footnotesize $^\P$The width of the selection function is chosen to be larger in the trait-based model than in the species-based model \protect\citep{hartvig_food_2011-1} to emulate the diversity in prey-preferences of the species within a trait-class. The practical implication of enlarging $\sigma$ is that the model is more stable (fewer oscillations) \protect\citep{datta_jump-growth_2010}.} \\
\multicolumn{5}{p{\textwidth}}{\footnotesize $^\ddagger$This value should be a little higher but it has been lowered to give a stable output which will facilitate analysis of model output.}\\
\multicolumn{5}{p{\textwidth}}{\footnotesize $^\S$If the value of the search exponent is set to $n$ a lot of the formulas involving exponential factors and power-laws of $\beta$ are simplified significantly as these factor then just becomes 1. Therefore using $q=n$ is preferred for analytical work.}

  \end{tabular}
\end{table}

\subsection{Trait-based model}
The trait-based size spectrum model can be derived as a simplification of the general model outline above. The idea is that all the species-specific parameters are the same, except for the asymptotic size, which is considered the most important ``trait'' characterizing a species.  Other parameters are related to the asymptotic size, i.e.~$w_m = \eta_m W$, where $\eta_m = 0.25$.  For the trait-based model the number of species is not important. For applications of the trait-based model see \citet{andersen_damped_2010} and \citet{andersen_direct_2010}.

Setting up a trait-based model is explored in Section~\ref{sec:trait_based_model}.

\subsection{Community model}
\label{sec:community_model_intro}
The simplest version of the size-based model is the community model, originally introduced by \citep{benoit_continuous_2004}. The community model can be derived as a simplification of the trait-based model \citep{zhang_trait_2013}.  In this model only one ``species'' is resolved. Reproduction is not resolved, so $\psi(w)=0$ and the recruitment flux $R$ is set to be constant.
Standard metabolism is turned off by setting $k_{s}$ to 0.
Growth is therefore given by the simpler equation:
\begin{equation}
    \label{eq:comm_growth}
    g(w) = \alpha f_(w) h w^n
\end{equation}

where $f_(w) h w^n$ is the consumed food and $\alpha$ is the efficiency with which the consumed food is transformed into growth.
The growth rate can also be written as:

\begin{equation}
  \label{eq:2}
  g(w) = \overline{\epsilon}_I E_a
\end{equation}
where $\overline{\epsilon}_I$ is the average growth efficiency which can be derived from the full model, see \citet{andersen_trophic_2009} or \cite{zhang_trait_2013}.

Setting up a community model is explored in Section~\ref{sec:community_example}.

\subsection{Parameters}
\label{sec:parameters}
%DOES THIS SECTION ONLY APPLY TO COMMUNITY AND TRAIT BASED MODELS?
%IN NS MODEL GAMMA IS SET HOW?
%CAN ADD TO MIZERPARAMS CONSTRUCTOR OTHERWISE

The default parameter values for the model have been derived on the basis of meta-analyses of data on marine fish (Table \ref{tab:parameters}). Two parameters deserving special mention in the following is the initial and critical feeding levels which are used as physiological measures characterizing the productivity of the system and the metabolic requirements of the individuals.

The system is driven by the production of the resource. The ratio between the production and the maximum consumption will determine the feeding level $f_0$ of small individuals feeding mainly on the resource. If $f_0$ is close to 1 the individuals are satiated, and growth will be largely independent of changes in food availability. If $f_0$ is in the linear range of the functional response, growth will be dependent on available food. If $f_0$ is close to the critical feeding level $f_c$, where the available food is only sufficient to cover standard metabolism, growth will be stunted. The initial feeding level $f_0$, calculated as the feeding level of an individual feeding on the resource at carrying capacity, is used as the control parameter for the resource productivity. The initial feeding level is then used to calculate the search rate parameter $\gamma$:

\begin{equation}
  \label{eq:gamma}
  \gamma_i(f_0) = \frac{f_0 h_i \beta_i^{2-\lambda}}{(1-f_0)\sqrt{2\pi}\kappa \sigma_i}.
\end{equation}

Similar to the way the initial feeding level $f_0$ is used to describe the relation between the production and the maximum consumption, the critical feeding level $f_c$ (\ref{eq:fc}) is used to describe the relation between the factors for standard metabolism $k_s$ and maximum consumption $h$. A critical feeding level of $f_c \approx 0.2$ seems to be reasonable \citep{hartvig_food_2011-1}.

The free parameter $\kappa$ may in principle be determined analytically, based on an assumption that all species have maximum recruitment, $R_i = R_{\mathrm{max}.i}$.
However, the depletion of resources makes it difficult to find an analytical approximation of $\kappa$ and until that has been achieved, $\kappa$ has to be adjusted manually such that the resulting community spectrum forms a continuation of the resource spectrum.


%--------------------------------------------------------------------
\section{Introducing \pkg{mizer}}

The \pkg{mizer} package can be used to implement size-based ecological models.
With \pkg{mizer} is is possible to implement the three types of model described above (with increasing complexity): community, trait-based and food-web, using the same basic tools and methods.
In this vignette we present examples of how to set up, project and analyse all three types of model.

Using the package is relatively simple.  There are three main stages:

\begin{itemize}
    \item Setting the model parameters. This is done by creating an object of class \class{MizerParams}. This includes model parameters such as the life history parameters of each species, and the range of the size spectrum. It is possible to create a \class{MizerParams} object directly using the class constructor or by using one of the convenient wrapper functions provided in the package.
    \item Running a simulation. This is done by calling the \code{project()} method on the model parameters. This produces an object of \class{MizerSim} which contains the results of the simulation. The \code{project()} method controls the length and time-step of the simulation, as well as the levels of fishing effort.
    \item After a simulation has been run, the results can be explored using a range of plots and summaries.
\end{itemize}

These stages and the accompanying classes and methods are explained in detail in later sections.
However, it is probably easier to learn the basics of \pkg{mizer} through examples. The next few sections show how to implement different types of size based model.

%------------------------------------------------------
\section{Implementing a community-type model}
\label{sec:comm_model}

A size-structured community model is the simplest type of model that can be created with \pkg{mizer}. In this section we descibe how a community model can be set up and projected through time. We then use them to illustrate the idea of a 'tophic cascade'. Due to the relative simplicity of this type of model they are useful for gently introducing some of the concepts behind the \pkg{mizer} package. Consequently, this section should hopefully serve as an introduction to using \pkg{mizer} and some of the main classes and methods, but avoids too many details. Further information and more details of the package can be found later on.

 The concept of the community model was introduced in Section \ref{sec:community_model_intro}. There are several key features of the community model that differentiate it from the other model types. Only one 'species' is resolved, i.e. one 'species' is used to represent the whole community. Recruitment to the smallest size in the community spectrum is constant, i.e. there is no relationship between species abundance and recruitment. The proportion of energy invested in reproduction is set to 0 and standard metabolism has been turned off. This means that the growth rate of species is determined solely by the assimilated food. The resource spectrum only extends to the start of the community spectrum. 

\subsection{Setting up a community model}
\label{sec:set_up_comm_model}
As mentioned above, the first stage in using \pkg{mizer} is to create an object of class \class{MizerParams}. This class contains the model parameters including the life-history parameters of the species in the model, the stock-recruitment relationships, the harvesting selectivity functions and the parameters of the resource spectrum. The class is fully described in Section~\ref{sec:MizerParams}.

To avoid having to make a \class{MizerParams} object directly, a wrapper function, \code{set\_community\_model()}, has been provided that conveniently creates a \class{MizerParams} object specifially for a community model. The documentation for the function can be seen by entering:

<<label=help_set_community_model, eval=FALSE>>=
?set_community_model
@

As can be seen in the help page, the function can take many arguments. These are passed on to the \class{MizerParams} constructor when the function is called. We can ignore most of these arguments for the moment as they almost all come with default values. Full details of those arguments can be seen in Section~\ref{sec:MizerParams}.

The parameters that you should pay attention to are: $z0$ (the level of background mortality), $alpha$ (the assimilation efficiency of the community), $f0$ (the average feeding level of the community which is used to calculate $\gamma$ in equation~\ref{eq:gamma}) and $recruitment$ (the level of constant recruitment).

Although default values for these parameters are provided, you are encouraged to explore how changing the values affects the simulated community. For example, the default value of $z0$ is 0.1. Increasing this value effectively 'shortens' the length of the community spectrum. 
The value of the constant recruitment should be set so that the community spectrum is a continuation of the background spectrum. This can be done with trial and error.  A reasonable value for \code{alpha} is 0.2 \citep{andersen_life-history_2008}. 

The \code{set\_community\_model()} function is called by passing in the arguments by name. Any parameter that is not passed in is set to the default value. For example, the following line sets up the parameters with $z0$ = 1, $f0$ = 0.7, $alpha$ = 0.2 and the constant recruitment ($recruitment$) = 4e7. All other parameters will have their default value:

<<label=demo_comm_model_params>>=
params <- set_community_model(z0 = 0.1, f0 = 0.7, alpha = 0.2, recruitment = 4e7)
@

Calling the function creates and returns an object of type \class{MizerParams}. We can check this using the \code{class()} function.
<<label=class_comm_params>>=
class(params)
@

If you are going through this vignette for the first time, it is likely that you have no idea what a \class{MizerParams} object actually is. In 'R-speak' it is an \code{S4} object, which means it is an object made up of 'slots'. Slots are essentially containers that store the object data. These slots can be seen by calling the \code{slotNames()} method on the object:

<<label=slots_MP>>=
slotNames(params)
@

As you can see, the \code{params} object is made up of lots of slots. They are discussed in detail in Section~\ref{sec:MizerParams} and summarised in TABLE X. These slots are accessed by using the \code{@} operator. For example, to access the \code{w} slot (which contains a vector of the size bins in the model) you would use:

<<label=demo_slot_accessor, results=hide>>=
params@w
@

Don't worry about this for the moment. It is unlikely that you will need to access the slots directly at this stage. Rather than picking through the slots to find out what is in a particular \class{MizerParams} object, a summary of the object can be seen by calling the \code{summary()} method on it:

<<label=summary_comm_params>>=
summary(params)
@

In the summary you can see that the size range of the community spectrum has been set from \Sexpr{min(params@w)} to \Sexpr{max(params@w)} and these are spread over \Sexpr{length(params@w)} size bins. Similar information is available for the background resource spectrum.
Additionally, the community is made up of one species, called ''Community'', which has an asymptotic size of \Sexpr{params@species_params$w_inf[1]} and a preferred predator prey mass ratio of \Sexpr{params@species_params$beta[1]}. The $w\_mat$ parameter has been set to NA as it is not used when running a community model. These values have all been set by default using the \code{set\_community\_model()} function. If you want to set different values for these, you will need to call the \code{set\_community\_model()} function with the desired values. 

\subsection{Running the community model}
\label{sec:running_comm_model}
By using the \code{set\_community\_model()} method we now have a \class{MizerParams} object that contains all the information we need about the community. We can use this to perform a simulation and project the community through time.
In the \pkg{mizer} package, projections are performed using the \code{project()} method. You can see the help page for \code{project()} for more details and it is described fully in Section~\ref{sec:projection}.
We will ignore the details for the moment and just use \code{project()} to run some simple projections.
The arguments for \code{project()} that we need to be concerned with are $effort$, which determines the fishing effort through time and therefore fishing mortality through time, and $t\_max$, which is the length of the simulation.
Initial population abundances are set automatically by the \code{get\_initial\_n()} function. It is possible to set your own initial abundances but we will not do this here.

To run a projection for 50 time steps, with no fishing effort (i.e. we want to model an unexploited community) we run:
<<label=demo_comm_run>>=
sim <- project(params, t_max=50, effort = 0)
@

The resulting object is of type \class{MizerSim}. This class holds the results of the simulation, including the community and background resource abundances at size through time, as well as the original model parameters. It is explained in detail in Section~\ref{sec:projection}.

After running the projection, it is possible to explore the results using a range of plots and analyses. These are described fully in Section~\ref{sec:exploring}. To quickly look at the results of the projection you can call the generic \code{plot()} method. This plots the feeding level, predation mortality, fishing mortality and abundance by size in the last time step of the simulation, and the biomass through time (Figure~\ref{fig:plot_comm_demo}).

<<plot_comm_sim, eval=FALSE>>=
plot(sim)
@

% \SweaveOpts{width = 7, height = 10}
% Or use the width and height option in the <<>>= bit
% Whar is the difference and how to make them universal?
	
%The Sweave options width and height influence the dimensions of the PDF file but not the size of the figures in the document. Put something like
%\setkeys{Gin}{width=0.4\textwidth}
%after \begin{document} to get smaller plots.

% Putting it in <<>>= bit makes the figure the right size in the document, without making the text bigger or anything.
\begin{figure}
<<label=print_plot_comm_sim, fig=TRUE, echo=FALSE, width = 7, height = 10>>=
<<plot_comm_sim>>
@
\caption{Example plot of the community model}
\label{fig:plot_comm_demo}
\end{figure}

In Figure~\ref{fig:plot_comm_demo} there are several things going on that are worth talking about. Looking at how the total biomass of the community changes with time, you can see that the biomass reaches a stable equilibrium. The other panels show what is happening at the last time step in the simulation, which in this case is when the community is at equilibrium.
Fishing mortality is 0 because we set the $effort$ argument to 0 when running the simulation.
The predation mortality rate (M2) is clearly a function of size, with the smallest sizes experiencing the highest levels of predation.
The feeding level describes how satiated an individual is, with 0 being unfed, and 1 being full satiated. The feeding level at size will be strongly affected by the values of the $f0$ and $alpha$ arguments passed to the \code{set\_community\_model()} function.
The background resource and community sprectra are shown in the bottom panel of the plot (the plotted background resource spectrum has been truncated to make for a better plot, but really extends all the way back to \Sexpr{signif(params@w_full[1],3)} g).
You can see that the community spectrum forms a continuum with the resource spectrum. This is strongly affected by the level of fixed recruitment (the $recruitment$ argument passed to \code{set\_community\_model()}).

Note the 'spike' in biomass at the largest end of the community spectrum. This is because the size-based model can be broadly described as 'big things eating little things'. If this is true, what is eating the very biggest things? Without fishing pressure, the mortality of the largest individuals is only from the background mortality, $z0$. The mortality from predation is almost 0. This is difficult to see in the plot due to the $M2$ being so high for the smaller individuals. Consequently, there is a spike in abundance of the largest individuals.
%This leads to a corresponding lower decrease in predation mortality on the prey of the largest individuals, and therefore their abundance declines (the dip in biomass you can see near the end community spectrum).  
We can see this by extracting the predation mortality information from the \class{MizerSim} object, \code{sim}, that we created above.
This is easily done by using the \code{getM2()} method (See the help page for more details. There are several methods that can be used for extracting information from a \class{MizerSim} object, e.g. \code{getFeedingLevel()} and \code{getFMort()}. For more information see Section~\ref{sec:exploring}.):

<<label=get_m2_comm>>=
m2 <- getM2(sim)
@

This \code{m2} object is a array that contains the predation mortality at time by species by size. Here we only have one species so the species dimension is dropped, leaving us with a two dimensional array of time by size. We projected the model for \Sexpr{dim(m2)[1]-1} time steps but the length of the time dimension is \Sexpr{dim(m2)[1]} as the initial population is also included as a time step.

To pull out the predation mortality at size in the final time step we use:
<<label=m2_comm_final_time_step, results=hide>>=
m2[51,]
@

If you plot this predation mortality on log-log scale you can see how the predation mortality declines to almost zero for the largest sizes (Figure~\ref{fig:plot_comm_m2}).

\begin{figure}
<<label=print_plot_comm_m2, fig=TRUE, echo=FALSE>>=
plot(x = sim@params@w, y = m2[51,], log="xy", type="l", xlab = "Size", ylab = "Predation mortality")
@
\caption{Predation mortality without fishing in the community model (note the log scales for both axes).}
\label{fig:plot_comm_m2}
\end{figure}

\subsection{Example of a trophic cascade with the community model}
\label{sec:trophic_cascade_comm_model}
It is possible to use the community model to simulate a trophic cascade, similar to those seen in \citet{andersen_damped_2010}.
To do this we need to perform two simulations, one with fishing and one without.  This means we need to consider the fishing selectivity function.

The \code{set\_community\_model()} automatically sets the fishing selectivity to be have knife-edge shape, with only individuals larger than 1 kg selected (the size at the knife-edge can be changed by setting the $knife\_edge\_size$ argument). Although it is possible to change the selectivity function, here we will use the default knife-edge selectivity.

<<label='set_comm_fishing'>>=
params_knife <- set_community_model(z0 = 0.1, recruitment = 4e7, alpha = 0.2, f0 = 0.7, knife_edge_size = 1000)
@

First we perform a simulation without fishing in the same way we did above by setting the $effort$ argument to 0:

<<label=sim_comm_no_fish>>=
sim0 <- project(params_knife, effort = 0, t_max = 50)
@

Now we want to simulate again, this time with fishing. In the simulations, fishing mortality is calculated as the product of the fishing selectivity, effort and catchability (see Section~\ref{sec:fishing_gear} for more details). By default catchability is set to 1. This means that a fishing effort of 1 will result in a fishing mortality of 1 for fully selected sizes. Here we run a simulation with fishing effort set to 1 for the duration of the simulation:

<<label=sim_comm_with_fish>>=
sim1 <- project(params_knife, effort = 1, t_max = 50)
@

You can compare the difference between these scenarios by using the \code{plot()} method as before (Figure~\ref{fig:plot_comm_fmort}). Of particular interest is the fishing mortality at size. The knife-edge selectivity at 1000g can be clearly seen. An effort of 1 results in a fishing mortality of 1 for fully selected sizes.

<<label=plot_comm_fmort, eval=FALSE>>=
plot(sim1)
@

\begin{figure}
<<label=print_plot_comm_fmort, fig=TRUE, echo=FALSE>>=
<<plot_comm_fmort>>
@
\caption{Summary plot for the community model when fishing with knife-edge selectivity at size = 1000 g.}
\label{fig:plot_comm_fmort}
\end{figure}

To explore the presence of a trophic cascade, we are interested in looking at the relative change in abundance when the community is fished compared to when it is not fished. To do this we need to get the resulting abundances at size from the simulation objects. The abundances are store in the \code{n} slot of the \class{MizerSim} objects. The \code{n} slot returns a three dimensional array with dimensions time x species x size. Here we have 51 time steps (50 from the simulation plus one which stores the initial population), 1 species and 100 sizes:

<<label='dim_n'>>=
dim(sim0@n)
@

We want the abundances in the final time step, and we can use these to calculate the relative abundances:

<<label='relative_comm_abundance'>>=
relative_abundance <- sim1@n[51,,] / sim0@n[51,,]
@

\begin{figure}
<<label=plot_relative_comm_abund, fig=TRUE, echo=FALSE>>=
plot(x=sim0@params@w, y=relative_abundance, log="x", type="n", xlab = "Size (g)", ylab="Relative abundance")
lines(x=sim0@params@w, y=relative_abundance)
lines(x=c(min(sim0@params@w),max(sim0@params@w)), y=c(1,1),lty=2)
@
\caption{Relative abundances from the unfished (dashed line) and fished (solid line) community model.}
\label{fig:plot_relative_comm_abund}
\end{figure}

This can then be plotted (Figure~\ref{fig:plot_relative_comm_abund}).
The impact of fishing on species larger than 1000g can be clearly seen.
As described in \citep{andersen_damped_2010}, the fishing pressure lowers the abundance of large fish. This then relieves the predation pressure on their smaller prey (the preferred predator-prey size ratio is given by the $beta$ parameter, which is set to 100 by default), leading to an increase in their abundance. This in turn increases the predation mortality on their smaller prey, which reduces their abundance and so on.  
This impact can be seen by plotting the predation mortality (Figure~\ref{fig:plot_m2_comm}).
%This can be seen using the \code{getM2()} method for \class{MizerSim} objects (see the help page for more details).
%Only a selected size range is plotted to illustrate the impact (Figure ~\ref{fig:plot_m2_comm}).

<<label='get_M2_comm'>>=
m2_no_fishing <- getM2(sim0)[51,]
m2_with_fishing <- getM2(sim1)[51,]
@

<<label=plot_relative_comm_m2, eval=FALSE>>=
w_idx <- sim0@params@w >= 1
plot(x=sim0@params@w, y=m2_with_fishing, log="x", type="l", xlab = "Size (g)", ylab="Predation mortality", ylim=c(0,2))
lines(x=sim0@params@w, y=m2_no_fishing, lty=2)
@

\begin{figure}
<<label=print_plot_relative_comm_m2, fig=TRUE>>=
<<plot_relative_comm_m2>>
@
\caption{Predation mortalities from the unfished (dashed line) and fished (solid line) community model.}
\label{fig:plot_m2_comm}
\end{figure}

\subsection{The impact of changing $\sigma$}
\label{sec:comm_model_change_sigma}

As described above, the $\sigma$ parameter determines the width of the predator prey size preference. Here we take a look at how changing the value of $\sigma$ can affect the dynamics of the community.
In the examples above, $\sigma$ is set in the \code{set\_community\_model()} function by default to a value of \Sexpr{params_knife@species_params$sigma[1]}.
When projected through time, the community abundances converge to a stable equilibrium.
What happens if we reduce the value of $\sigma$, for example by setting it to 1.0? We can do this by passing in the new value of $\sigma$ into \code{set\_community\_model()}.

<<label=comm_params_sigma1>>=
params_sigma1 <- set_community_model(z0 = 0.1, f0 = 0.7, alpha = 0.2, recruitment = 4e7, sigma = 1)
@

We want to project this new model through time using the \code{project()} method. However, note here that we are projecting the model by 50 time steps. More importantly note that we have introduced a new argument: $dt$. This is the step size of the solver. It does not have anything to do with the biology in the model. It only affects the internal engine of \code{project()} that performs the projection. 
As you can see in the underlying model equations in Section~\ref{sec:principles}, the model runs in continuous time. Therefore, to project it forward, \code{project()} must solve the system of equations using approximations. The quality of these approximations is strongly affected by $dt$. 
The default value of $dt$ is 0.1, which will be fine for most of the projections we run in this Vignette. Here it is necessary to reduce the value to 0.01 to avoid introducing any artefacts into the projected values. Decreasing $dt$ increases the time it takes to run a projection.
Here we project the new parameters object for 100 time steps without fishing:

<<label=comm_project_sigma1>>=
sim_sigma1 <- project(params_sigma1, effort = 0, t_max = 50, dt=0.01)
@

Let's take a look at how the abundances change through time. We can do this with the \code{plotBiomass()} method:

<<label=plot_comm_biomass_sigma1, eval=FALSE>>=
plotBiomass(sim_sigma1)
@

\begin{figure}
<<plot_comm_biomass_sigma1, fig=TRUE>>=
<<plot_comm_biomass_sigma1>>
@
\caption{Biomass of the community model when $\sigma$ is reduced to a value of 1.0.}
\label{fig:plot_comm_biomass_sigma1}
\end{figure}

Figure~\ref{fig:plot_comm_biomass_sigma1} shows that abundances of the community no longer converge to a stable equilibrium and the dynamics appear to be chaotic. The ecological significance of the change in dynamics, and of the ability of simple community models to show chaotic behaviour, is still being debated. It can be argued that the size of the oscillations are too large to be 'true'. Additionally, when a trait-based model (see Section~\ref{sec:trait_based_model}) is implemented, the magnitude of the oscillations are much smaller.

%-----------------------------------------------------------------------
\section{Implementing a trait-based model}
\label{sec:trait_based_model}

\subsection{Setting up a trait-based model}
\label{sec:set_up_trait_model}
As mentioned in the introduction, the trait-based size spectrum model is a simplification of the general size spectrum model (see \citet{andersen_damped_2010} and \citet{andersen_direct_2010}). Unlike the community model described in Section \ref{sec:comm_model}, more than one species is resolved in the trait-based model. Here, the asymptotic size is considered to be the most important ``trait'' characterizing a species. All of the species-specific parameters, such as $\beta$ and $\sigma$, are the same for all species. Other model parameters are determined by the asymptotic size. For example, $w_m = \eta_m W$, where $\eta_m = 0.25$.  The number of species is not important and does not affect the general dynamics of the model. The asymptotic sizes of the species are spread evenly over the size range of the community.

To help set up a trait-based model, there is a wrapper function, \code{set\_trait\_model()}. Like the \code{set\_community\_model()} function described above, this function can take many arguments. Most of them have default values so you don't need to worry about them for the moment. See the help page for more details.

<<label=help_set_trait_model, eval=FALSE>>=
?set_trait_model
@

The main parameters of interest are the number of the species in the model (\code{no\_sp}) and the minimum and maximum asymptotic sizes (\code{min\_w\_inf} and \code{max\_w\_inf} respectively, the asymptotic sizes are spread evenly on a logarithmic scale).

One of the key differences between the community type model described above and the trait-based model is the stock-recruitment relationship (SRR).
In the community model, recruitment is constant and there is no relationship between the abundance in the community and egg production.
In the trait-based model, the SRR is modeled using a ''Beverton-Holt'' type function (the default in \pkg{mizer}, see Section~\ref{sec:recruitment}) where recruitment flux $R_i$ (numbers per time) approaches a maximum recruitment as the egg production increases.
This maximum recruitment value for each species is linearly related to its asymptotic size on a log-log scale using the relationship $r\_{max} = r\_{max_mult} * w\_{inf} ^(r\_{max_slope})$, where $r\_{max_slope}$ and $r\_{max_mult}$ are the same for each species and are arguments that can be passed to the \code{set\_trait\_model()} function (there are default values).

Here we set up the model to have 10 species, with asymptotic sizes ranging from 10 g to 100 kg. All the other parameters have default values. 

<<label=demo_trait_model_params>>=
params <- set_trait_model(no_sp = 10, min_w_inf = 10, max_w_inf = 1e5)
@

This function returns an object of type \class{MizerParams}, which holds all the model information including species paramaters.

<<label=class_trait_params>>=
class(params)
@

This object can therefore be interrogated in the same way as described in Section~\ref{sec:comm_model} above, either by inspecting the individual slots or by using the \code{summary()} function.

<<label=summary_comm_params>>=
summary(params)
@

The summary shows us that now we have 10 species in the model, with asymptotic sizes ranging from \Sexpr{min(params@species_params$w_inf)}
to \Sexpr{max(params@species_params$w_inf)}. The size at maturity ($w\_{mat}$) is linearly related to the asymptotic size. Each species has the same preferred predator-prey mass ratio parameter values ($beta$ and $sigma$, see Equation \ref{eq4}). There are \Sexpr{length(params@w)} size bins in the community and \Sexpr{length(params@w_full)} size bins including the background community.
Ignore the summary section on fishing gear for the moment. This is explained below.

\subsection{Running the trait-based model}
\label{sec:running_trait_model}

As with the community model described above, we can project the model through time using the \code{project()} method.
Here we project the model for 50 time steps and without any fishing (the $effort$ argument is set to 0). We use the default initial population abundances given by the \code{get\_initial\_n()} function so there is no need to pass in any population values (see Section \ref{sec:setting_initial_abundances}).

<<label=trait_project_no_fishing>>=
sim <- project(params, t_max=50, effort = 0)
@

This results in a \class{MizerSim} object which contains the original \class{MizerParams} object, as well as the abundances of the community and the background spectra through time.
We can get a quick overview of the simulation by calling the generic \code{plot()} method:

<<plot_comm_sim, eval=FALSE>>=
plot(sim)
@

\begin{figure}
<<label=print_plot_trait_sim, fig=TRUE, echo=FALSE>>=
<<plot_comm_sim>>
@
\caption{Example plot of the trait-based model with no fishing.}
\label{fig:plot_trait_demo}
\end{figure}

The summary plot has the same panels as the one generated by the community model, but here all the species in the community are plotted (Figure~\ref{fig:plot_trait_demo}). The panels show the situation in the final time step of the simulation, apart from the biomass through time plot.

As this is a trait-based model where all species fully interact with each other, the predation mortality (M2) and feeding level by size is the same for each species.
The biomass quickly settles down to equilibria. In this simulation we turned fishing off so the fishing mortality is 0.
The size-spectra show the abundances at size to be evenly spaced by asymptotic size.

\subsection{Example of a trophic cascade with the trait-based model}
\label{sec:trophic_cascade_trait_model}

As with the community model, it is possible to use the trait-based model to simulate a trophic cascade, similar to those seen in \citet{andersen_damped_2010}.
Again, we perform two simulations, one with fishing and one without. We therefore need to consider how fishing gears and selectivity have been set up by the \code{set\_trait\_model()} function. 

The default fishing selectivity function is a knife-edge function, which only selects individuals larger than 1 kg. There is also only one fishing gear in operation, and this selects all of the species. You can see this if you call the \code{summary()} method on the $params$ argument we set up above. At the bottom of the summary there is a section on ''Fishing gear details''. You can see that the there is only one gear, called ''knife\_edge\_gear'' and that it selects species 1 to 10.
To control the size at which individuals are selected there is a \code{knife\_edge\_size} argument to the \code{set\_trait\_model()} function. This has a default value of 1 kg.

In \pkg{mizer} it is possible to include more than one fishing gear in the model and for different species to be caught by different gears. We will ignore this for now, but will explore it further below when we discuss food web models. 

To set up the trait-model with fishing we set up the \class{MizerParams} object in exactly the same way as we did before but here the $knife\_edge\_size$ parameter is explicitly passed in for clarity.

<<label=set_trait_fishing>>=
params_knife <- set_trait_model(no_sp = 10, min_w_inf = 10, max_w_inf = 1e5, knife_edge_size = 1000)
@

First we perform a simulation without fishing in the same way we did above by setting the $effort$ argument to 0:

<<label=sim_trait_no_fish>>=
sim0 <- project(params_knife, effort = 0, t_max = 50)
@

Now we simulate with fishing. Here, we use an effort of 1. As mentioned earlier, the fishing mortality on a species is the product of effort, catchability and selectivity (see Section~\ref{sec:fishing_gear} for more details). Selectivity ranges between 0 (not selected) and 1 (fully selected). By default catchability has a value of 1. Therfore, in this simulation the fishing mortality of a fully selected individual is simply given by the effort. This effort is constant throughout the duration of the simulation (however, this is does not necessarily have to be the case, see Section\ref{sec:projection}).

<<label=sim_trait_with_fish>>=
sim1 <- project(params_knife, effort = 1, t_max = 50)
@

We can plot the summary of the fished community using the default \code{plot()} function (Figure \ref{fig:plot_trait_fmort}). The knife-edge selectivity at 1000g can be clearly seen in the fishing mortality panel:

<<label=plot_trait_fmort, eval=FALSE>>=
plot(sim1)
@

\begin{figure}
<<label=print_plot_trait_fmort, fig=TRUE, echo=FALSE>>=
<<plot_trait_fmort>>
@
\caption{Summary plot for the trait-based model when fishing with knife-edge selectivity at size = 1000 g.}
\label{fig:plot_trait_fmort}
\end{figure}

The trophic cascade can be explored by comparing the total abundances of all species at size when the community is fished and unfished.
As mentioned above, the abundances are stored in the \code{n} slot of the \class{MizerSim} object. The \code{n} slot returns a three dimensional array with dimensions time x species x size. Here we have 51 time steps (50 from the simulation plus one which stores the initial population), 10 species and 100 sizes:

<<label='dim_n'>>=
dim(sim0@n)
@

As with the community model, we are interested in the relative total abundances by size in the final time step  so we want to pull out the 51st time step from the abundances and sum over the species.
We can use the \code{apply()} function to help us:

<<lable = total_abund_trait>>=
total_abund0 <- apply(sim0@n[51,,],2,sum)
total_abund1 <- apply(sim1@n[51,,],2,sum)
@

We can then use these vectors to calculate the relative abundances:

<<label='relative_comm_abundance'>>=
relative_abundance <- total_abund1 / total_abund0
@

Which can be plotted using:

<<label=plot_relative_comm_abund, eval=FALSE>>=
plot(x=sim0@params@w, y=relative_abundance, log="xy", type="n", xlab = "Size (g)", ylab="Relative abundance", ylim = c(0.1,10))
lines(x=sim0@params@w, y=relative_abundance)
lines(x=c(min(sim0@params@w),max(sim0@params@w)), y=c(1,1),lty=2)
@

\begin{figure}
<<label=show_plot_relative_comm_abund, fig=TRUE, eval=FALSE>>=
<<plot_relative_comm_abund>>
@
\caption{Relative abundances from the unfished (dashed line) and fished (solid line) trait based model.}
\label{fig:plot_relative_comm_abund}
\end{figure}

The impact of fishing on species larger than 1000g can be clearly seen (Figure~\ref{fig:plot_relative_comm_abund}).
As described above and in \citep{andersen_damped_2010}, the fishing pressure lowers the abundance of large fish. This then relieves the predation pressure on their smaller prey (the preferred predator-prey size ratio is given by the $beta$ parameter, which is set to 100 by default), leading to an increase in their abundance. This in turn increases the predation mortality on their smaller prey, which reduces their abundance and so on.  

This impact can also be seen by looking at the predation mortality by size. 
The predation mortalities are retrieved using the \code{getM2()} method for \class{MizerSim} objects. This returns a 3D array of predation mortalities by time x species x size (see the help page for more details). As mentioned above, for the trait based model the predation mortality by size is the same for each species. Therefore we only look at the predation mortality of the first species. 

<<label='get_M2_trait'>>=
m2_no_fishing <- getM2(sim0)[51,1,]
m2_with_fishing <- getM2(sim1)[51,1,]
@

These can then be plotted (see Figure \ref{fig:plot_m2_comm}).
LOOKS EXACTLY THE SAME - HMMMM

<<label=plot_relative_trait_m2, eval=FALSE>>=
w_idx <- sim0@params@w >= 1
plot(x=sim0@params@w, y=m2_with_fishing, log="x", type="l", xlab = "Size (g)", ylab="Predation mortality", ylim=c(0,2))
lines(x=sim0@params@w, y=m2_no_fishing, lty=2)
@

\begin{figure}
<<label=print_plot_relative_comm_m2, fig=TRUE>>=
<<plot_relative_comm_m2>>
@
\caption{Predation mortalities from the unfished (dashed line) and fished (solid line) community model.}
\label{fig:plot_m2_comm}
\end{figure}


\subsection{Setting up an industrial fishing gear}
\label{sec:trait_additional_gear}

TRYING TO REPLICATE FIGURE 4 OF AP 2010 but not sure of selectivity pattern.

In this section we look a little more closely at how the fishing gears, selectivities and catchabilities are set up with \pkg{mizer}.

In these simulations we only want to operate an ''industrial'' fishery. Industrial fishing targets the small zooplanktivorous species that are typically used for fishmeal production. In the previous simulations we have had only fishing gear and that this has targetted all the species in the community.
Now we only want to have an industrial gear that only selects species which have an asymptotic size less than or equal to 500 g.
These species will be fully selected from their smallest size, i.e. for a knife-edge selectivity WHAT IS THE KNIFE-EDGE SIZE?

First of all we will set up a \class{MizerParams} object as before and look at what is going on.

<<label=set_trait_fishing_again>>=
params <- set_trait_model(no_sp = 10, min_w_inf = 4, max_w_inf = 1e6, k0 = 100, knife_edge_size = 1000)
@

SO ARE WE EFFECTIVELY ADDING IN A REVERSE KNIFE EDGE FOR SPECIES WITH WINF <= 500?
CHECK WITH KEN


%You can see Section~\ref{sec:fishing_gear} for more details).

%---------------------------------------------------
\section{Food-web models}

The previous sections have used the wrapper functions to set up \class{MizerParams} objects that are appropriate for community and trait-based simulations.
We now turn our attention to food-web models. These are potentially more complicated than the community and trait-based models and use the full power of the \pkg{mizer} package.

SOME INTRODUCTORY STUFF TO THE FOOD-WEB MODEL
WHAT ARE MAIN STEPS FROM TRAIT BASED AND COMMUNITY MODELS TO FOOD WEB? WHY DO WE USE THEM? THEY CAN MODEL SPECIFIC ECOSYSTEMS?

For example, each species may have different life history parameters; there may be multiple gear types with different selectivities targetting different groups of species (and some species may be targeted by more than one gear); the fishing effort of each gear may change with time instead of just being constant (which has been the case in the simulations we have looked at so far); the interactions between the species needs to be considered.

This means that to effectively use \pkg{mizer} for a food-web model we are going to have take a closer look at the \class{MizerParams} class and the \code{project()} method.
In the following sections we build up a food-web model for the North Sea.

We also take a closer look at some of summary plots and analyses that can be performed, for example, calculating a range of size-based indicators.

\section{The \class{MizerParams} class}
\label{sec:MizerParams}


Before any simulations can be run it is necessary to set the parameters
of the model.
This is probably the most complicated part of the using the \pkg{mizer} package so
we will take it slowly.

The \pkg{mizer} package has its own class for storing model parameters: \class{MizerParams}.
This class stores the:
\begin{itemize}
    \item life-history parameters of the species in the community, such as $W_{\infty}$;
    \item size-based biological parameters for the species, such as the search volume, $V(w)$;
    \item stock-recruitment relationship functions and parameters of each species;
    \item interaction matrix to describe the spatial overlap of pairs of species;
    \item parameters relating to the growth and dynamics of the background resource spectrum;
    \item fishing gear parameters: selectivity and catchability.
\end{itemize}

Note that the \class{MizerParams} class does not store any parameters that can vary through time,
such as fishing effort or population abundance. These are stored in the \class{MizerSim} class which
we will come to later in Section \ref{sec:projection}.

Although the \class{MizerParams} class seems complicated, it is relatively straightforward to set up and use.
Objects of class \class{MizerParams} are created using the constructor method \code{MizerParams()}.
This constructor method can take many arguments. However, creation is simplified because many of the arguments have default values.

In the rest of this section we look at the main arguments to the \code{MizerParams()}
constructor method.
To help understand how the constructor is used and how the \class{MizerParams} class
relates to the equations given in Section~\ref{sec:principles}, there is an example
section where we create example parameter objects using data that comes with the
\pkg{mizer} package.

\subsection{The species parameters}
\label{sec:species_parameters_dataframe}

Although many of the arguments used when creaing a \class{MizerParams} object are optional, there is one argument that must be supplied by the user: the species specific parameters. 
For each species in the model community you must supply the life-history parameters, the selectivity function parameters and the stock-recruitment function parameters.

The species parameters must all be stored in a single data.frame object.  The data.frame is arranged species by parameter, so each column of the parameter data.frame is a parameter and each row has the parameters for one of the species in the model.
Although it is possible to create the data.frame by hand in \R, it is probably easier to create the data externally as a .csv file (perhaps using a suitable open source spreadsheet such as LibreOffice) and then read the data into \R.

There are some essential columns that you must include in the parameter data.frame and that do not have default values.
Other columns do have default values, so that if you do not include them in the species parameter data.frame, they will be automatically added when the \class{MizerParams} object is created. 
A description of the columns of the species parameter data.frame and any default values can be seen Table~\ref{tab:species_params}.

LINK THESE PARAMETERS TO THE EQUATIONS IN SECTION 3


%\begin{sidewaystable}[ht]
\begin{table}[ht]
    \begin{center}
	%\begin{tabular}{r|p{7cm}|p{7cm}}
	%\begin{tabularx}{r|X|X}
	    %\begin{tabularx}{\linewidth}{r|p{7cm}|X}
	    \begin{tabularx}{\linewidth}{r|X|X}
	    \hline
	    Column name & Description & Default value \\
	    \hline
	    \multicolumn{3}{c}{Life history parameters} \\
	    \hline
	    species & Name of the species & Compulsory (no default)\\
	    w\_inf & The asymptotic mass of the species & Compulsory (no default)\\
	    w\_mat & Maturation mass. Used to calculate values for $\psi$. WHAT IS WMAT IN TERMS OF BIOLOGY? Is it the mass at first maturity? & Compulsory (no default)\\
	    h & Maximum food intake rate & Compulsory (no default) \\
	    gamma & Volumetric search rate & Compulsory (no default)\\
	    ks & Standard metabolism coefficient & Compulsory (no default)\\
	    beta & Preferred predator prey mass ratio & Compulsory (no default)\\
	    sigma & Width of prey size preference & Compulsory (no default)\\
	    z0 & Background mortality (constant for all sizes) & Compulsory (no default)\\
	    k & Activity coefficient & 0.0\\
	    alpha & Assimilation efficiency & 0.6 \\
	    erepro & Reproductive efficiency & 1 \\
	    w\_min & The size class that recruits are placed in. & smallest size class of the species size spectrum \\
	    \hline
	    \multicolumn{3}{c}{Fishing gear parameters (see Section~\ref{sec:fishing_gear} for more details).} \\
	    \hline
	    sel\_func & The name of the selectivity function to be used.  & "sigmoid\_length".\\
	    gear & The name of the fishing gear that selects the species. At the moment a species can only be selected by one gear. & Name of the species \\
	    catchability & The catchability of the fishing gear. & 1\\
	    %a & Length-weight conversion coefficient & Only necessary if length-weight conversion is used (e.g. if specifying length ranges when calculating indicators, or in the fishing selectivity function) \\
	    %b & Length-weight conversion power & See notes for column $a$\\
	    other columns & Other parameters used by the selectivity function. For example, if the default "sigmoid\_length" function is used then the parameters "l25","l50","a" and "b" must also be specified as columns (see Section~\ref{sec:fishing_gear}). & \\ 
	    \hline
	    \multicolumn{3}{c}{Stock recruitment parameters (see Section~\ref{sec:srr} for more details).} \\
	    \hline
	    other columns & Any arguments that appear in the stock-recruitment function must also have a column of values (see Section~\ref{sec:srr}) & \\
	%\end{tabular}
	\end{tabularx}
	\caption{Columns of the species parameters data.frame}
	\label{tab:species_params}
    \end{center}
%\end{sidewaystable}
\end{table}

You can see in Table~\ref{tab:species_params} that most of the species specific
parameters relate to the life history of the species.
The others relate to the gear selectivity function and the stock-recruitment relationship.
These are explained further in Sections~\ref{sec:fishing_gear} and \ref{sec:srr} respectively. 



\subsection{Fishing gears and selectivity}
\label{sec:fishing_gear}
%As well as life-history parameters, the parameter data.frame must also have columns that specify
%parameter values for the chosen fishing selectivity function. This is covered in more detail
%in Section~\ref{sec:fishing_gear}. In brief, any parameter that is used in the selectivity
%function (apart from size) must also be included in the parameter data.frame.
%For example, the default selectivity function uses the parameters \code{l25}, \code{l50},
%\code{a} and \code{b}. This means that if the default selectivity function is being used then
%these must also be included in the parameter data.frame.

In this section we take a look at how fishing is implemented and how fishing gears are set up within
\pkg{mizer}.

In \pkg{mizer}, fishing mortality is imposed on species by fishing gears.
The fishing mortality $F$ imposed by gear $g$ on species $s$ at size $w$ is calculated as:

\begin{equation}
    F_{s,g,w} = S_{s,g,w} Q_{s,g} E_{g}
\end{equation}

where $S$ is the selectivity by species, gear and size, $Q$ is the catchability by species
and gear and $E$ is the fishing effort by gear.
The selectivity at size has a range between 0 (not selected at that size) to 1 (fully selected at
that size).
Catchability is used as an additional scalar to make the link between gear selectivity, fishing
effort and fishing mortality. 
For example, it can be set so that an effort of 1 gives a desired fishing mortality.
In this way effort can then be specified relative to a 'base effort', e.g. the effort
in a particular year.
Fishing effort is not stored in the \class{MizerParams} object.
Instead, effort is set when the simulation is run and can vary through time (see Section~\ref{sec:projection}).

At the moment a species can only be selected by one fishing gear, although each gear can select more than one species (this is a limitation with the current package that will be developed in future releases).

The selectivity at size of each gear is given by a selectivity function. Some selectivity
functions are included in the package. New functions can be defined by the user. 
Each gear has the same selectivity function for all the species it selects, but the parameter
values for each species may be different, e.g. the lengths of species that a gear selects may be different.

The name of the selectivity function is given by the $sel\_func$ column in the species parameters data.frame.
Each selectivity function has a range of arguments. Values for these arguments
must be included as columns in the species parameters data.frame. The names of the columns must exactly
match the names of the arguments. 
For example, the default selectivity function is \code{sigmoid\_length}.
The arguments for this selectivity function can be seen in the help page
for this function. To see them enter:

<<eval=FALSE>>=
?sigmoid_length
@

It can be seen that the \code{sigmoid\_length} function has arguments \code{w}, \code{l25},
\code{l50}, \code{a} and \code{b}.
The first argument, \code{w}, is size (the function calculates selectivity at size).
All selectivity functions must have \code{w} as the first argument.
The values for the other arguments must be found in the species parameters data.frame.
This can be seen in the example in Section \ref{sec:params_example}.
If they are not there, an error is thrown when the \class{MizerParams} object is created.

Users are able to write their own size based selectivity function. The first argument to the
function must be \code{w} and the function must return a vector of the selectivity
(between 0 and 1) at size.

The name of the fishing gear is given in the $gear$ column of the species parameter
data.frame. If the $gear$ column is not specified, the default gear name is simply
the name of the species. This implies that each species is fished by a different gear.
This approach can be used to explore the impacts of changing fishing mortality on individual species.

\subsection{The stock-recruitment relationship}
\label{sec:srr}
%The parameter data.frame may also have columns that relate to the stock-recruitment function.
%This is covered in Section~\ref{sec:srr}.
%In brief, any parameter that is used
%by the stock-recruitment function (apart from the density independent recruitment value)
%must be included in the parameter data.frame.
%For example, the default stock-recruitment function is a Beverton-Holt
%type formulation which uses a parameter called $r_{max}$. Therefore, if the default
%stock-recruitment function is used, a column of values called $r_{max}$ needs to
%be included in the parameters data.frame.

The stock-recruitment relationship in \pkg{mizer} means something slightly
different to the standard fisheries terminology.
In standard fisheries science, 
recruitment means the abundance of new recruits entering the fishery
(e.g. the number of age 1 added to the population each year).
This recruitment is calculated by the stock-recruitment
relationship, based on some measure of the reproductive potential of
the stock, such as spawning stock biomass.

In \pkg{mizer} recruitment means the number of individuals that enter
the size-spectrum at the smallest size group of that species (given by the
parameter $w\_min$ in the species parameter data.frame).
As can be seen in Section~\ref{sec:principles}, 
calculating the recruitment involves calculating the 'density independent'
recruitment, $RDI$.
The $RDI$ is then modified by a stock-recruitment relationship
to impose some form of density-dependence. This then results in the
density-dependent recruitment, $RDD$.
Without this density dependence, the realised recruitment
to the smallest size class is determined only
by $RDI$.

The default stock-recruitment relationship is a Beverton-Holt type function
which has the form:

\begin{equation}
\label{eqtn:default_srr}    
    RDD = \frac{r_{max}.RDI}{r_{max}+RDI}
\end{equation}

where $r_{max}$ is a parameter which determines the maximum recruitment.

% Add a figure

Similar to the fishing selectivity functions, any parameter used in the
stock-recruitment function, other than $RDI$, must be in the species
parameter data.frame and the column must have the same name as the function argument.
For example, if the above default stock-recruitment function is to be
used then the species parameter data.frame must have an $rmax$ column.

Users are able to write their own stock-recruitment function. The first argument to the function must be \code{rdi}.

EXAMPLE - SEE FUNCTION

\subsection{The interaction matrix}
\label{sec:interaction_matrix}

The interaction matrix describes the interaction of each pair of species
in the model. This can be viewed as a proxy for spatial interaction
e.g. to model predator-prey interaction that is not size based.
The values in the interaction matrix are used to scale the size-based predation pressure.
The matrix is square with every element being the interaction between a pair
of species. The dimensions, nrows and ncolumns, therefore equal the number of species.
The values are between 0 (species do not overlap and
therfore do not interact with each other) to 1 (species overlap perfectly).
If all the values in the interaction matrix are set to 1 then predator-prey
interactions are determined entirely by size-preference.

The interaction matrix must be of type \code{array} or \code{matrix}. 
One way of creating your own is to enter the data using a spreadsheet 
(such as LibreOffice) and saving it as a .csv file. 
The data can be read into \R using the commmand \code{read.csv()}. This reads
in the data as a data.frame. We then need
to convert this to a matrix using the \code{as()} function. 
An example of how to do this is given in Section~\ref{sec:params_example}.

It should be noted that the order of species in the interaction
matrix has to be the same as the order in the species parameters data.frame.
Although you can specify the dimnames of the interaction matrix, these names
are overwritten by the species names from the species parameters data.frame
inside the \class{MizerParams} constructor.

If an interaction matrix is not specified to the \code{MizerParams()}
contructor the default interation matrix is used. This has all values set to 1. 

\subsection{The other \code{MizerParams()} arguments}
\label{sec:other_mizerparams_arguments}

As well as the essential species parameters data.frame and the interaction
matrix, there are several other arguments to the \code{MizerParams} constructor.
These have default values.  Although it is tempting to just charge on and use the default
values, many of the values come from a particular model of the
North Sea (REF NSPAPER) and so may not be appropriate for what you are doing.
We'll look at these arguments here, describe what they do and
discuss how to choose appropriate ones for your model (TODO).
The arguments can be seen in Table \ref{tab:other_params}.

\begin{table}[ht]
    \begin{center}
	\begin{tabularx}{\linewidth}{r|X|X}
	\hline
	Argument & Description & Default value \\
	\hline
	min\_w & The smallest size of the species community size spectrum. Note that this a different w\_min to the one in the species parameter data.frame. & 0.001 \\
	max\_w & The largest size of the species size spectrum. & The laegest w\_inf in the species parameters data.frame * 1.1 \\
	no\_w & The number of size bins in the species size spectrum. & 100 \\
	min\_w\_pp & The smallest size of the background size spectrum. & 1e-10 \\
	no\_w\_pp & The number of size bins in the background size spectrum. & round(no\_w) * 0.3 \\
	n & The scaling of intake. & 2/3 \\
	p & The scaling of standard metabolism. & 0.7 \\
	q & The search volume exponent. & 0.8 \\
	r\_pp & The growth rate of the primary productivity (the background spectrum). & 10 \\
	kappa & The carrying capacity of the background spectrum. & 1e11 \\
	lambda & The exponent of the background spectrum. & 2+q-n \\
	w\_pp\_cutoff & The cut off size of the background spectrum. & 10 \\
	\end{tabularx}
	\caption{Other parameters to the \code{MizerParams()} constructor}
	\label{tab:other_params}
    \end{center}
\end{table}

How to choose parameter values.

\subsection{Putting all this together: an example of making a simple \class{MizerParams} object}
\label{sec:params_example}

As mentioned in the preceeding sections, an object of \class{MizerParams}
is created by using the \code{MizerParams()}
constructor method. This takes the following arguments:
\begin{description}
    \item[object] The species parameter data.frame (see Section~\ref{sec:species_parameters_dataframe}). This is compulsory with no default value.
    \item[inter] The interaction matrix (see Section~\ref{sec:interaction_matrix}). The default is a matrix of 1s.
    \item[...] Other model parameters (see Section~\ref{sec:other_mizerparams_arguments}).
\end{description}

In the rest of this section we demonstrate how to pull these elements together
to make \class{MizerParams} objects. 

The first step is to prepare the species specific parameter data.frame.
As mentioned above, one way of doing this is to use a spreadsheet
and save it as a .csv file. We will use this approach here.
An example .csv file has been included in the package.
This file is placed in the $doc$ folder of the package installation.
The location of the file can be found by running:

<<eval=FALSE>>=
system.file("doc/simple_species_params.csv",package="mizer")
@

This file can be opened with most spreadsheets or a text editor for you to inspect.
This can be loaded into \R using the following code (after you
have told \R to look in the right directory):

<<>>=
params_data <- read.csv("simple_species_params.csv")
@ 

This reads the .csv file into \R in the form of a data.frame.
You can check this with the \code{class}:

<<>>=
class(params_data)
@

%The first few lines of the data.frame can be inspected with
%the \code{head()} function.
The example data.frame can be inspected by entering the name
of the object.

<<>>=
params_data
@

This data set is for a model of the North Sea (REFERENCE).
There are \Sexpr{nrow(params_data)} species.
As you can see, we have all the essential life history columns as described in
Table~\ref{tab:species_params}, as well as some additional columns.

There is no $sel\_func$ column to determine the selectivity function.
This means that the default selectivity function, \code{sigmoid\_length},
will be used. However, as mentioned in Section~\ref{sec:fishing_gear},
this function also needs several other arguments. The species data.frame
therefore already includes the columns $a$, $b$, $l25$
and $l50$ for the default selectivity function.

Similarly, the column $r\_max$ is the parameter for the default stock-recruitment
function described in Section~\ref{sec:srr}.

The values of the non-essential species specific parameters $alpha$ and $erepro$,
are not included in the data.frame. This means that the default values
will be automatically used when we create the \class{MizerParams} object.

Strictly speaking, this species parameter data.frame is the minimum
we need to create a
\class{MizerParams} object. However, the model would be improved
by also including a case study specific interaction matrix.

An example interaction matrix has been included in \pkg{mizer}
as a .csv file.  The location of the file can be found by running:

<<eval=FALSE>>=
system.file("doc/inter.csv",package="mizer")
@

Take a look at it in a spreadsheet if you want.
As mentioned above, to read this file into \R we can make
use of the \code{read.csv()} function. However, this time
we want the first column of the .csv file to be the row
names. We therefore use an additional argument to the \code{read.csv()}
function: \code{row.names}.


<<>>=
inter <- read.csv("inter.csv", row.names=1)
@

The \code{read.csv()} function reads the data into a data.frame.
We want the interaction matrix to be of class \class{matrix} so
we need to make use of the \code{as()} function.

<<>>=
inter <- as(inter, "matrix")
@

We now have the species parameters data.frame and the interaction
matrix.
To make the \class{MizerClass} object you just call the constructor method
and pass in the arguments.
We will use default values for the remainder of the arguments
to the \code{MizerParams()} method. These are given in Table~\ref{tab:other_params}.
This means that we only need to pass in two arguments to the constructor:

<<>>=
params <- MizerParams(params_data, interaction = inter)
@

Note that the first argument must be the species parameters data.frame.
The remaining arguments can be in any order but should be named.
If we didn't want to use default values for the other arguments we would pass
them in to the constructor by name. For example, if wanted our species size spectrum
to have 200 size bins instead of 100 (the default) we would use:

<<eval=FALSE>>=
params <- MizerParams(params_data, interaction = inter, no_w = 200)
@

The above command creates an object of class \class{MizerParams}. 
But what does that mean?
The method uses the parameters specified in the arguments
and the default values to implement some of the equations described in 
Section~\ref{sec:principles} and calculate parameters for the model. 

As mentioned above, an object of class
\class{MizerParams} stores a wide range of model parameters. This 
information is held in what are known as 'slots'.  A description
of these slots can be found by calling \code{help()} on the class:

<<eval=FALSE>>=
help("MizerParams-class")
@

A list of the slots can also be seen using the \code{slotNames()} method.
The different slots can be accessed using the \code{@} operator.
For example, to look at the search volume slot, \code{search\_vol}
you enter:

<<results=hide>>=
params@search_vol
@

(the results are not shown here as the array is pretty huge)

The slot $species\_params$ contains the species parameters data.frame
that was passed in to the constructor. Now it also contains
any default values (for example, $alpha$) that may not have been
included in the original data.frame.

Also note how the default fishing gears have been set up.
Because we did not specify gear names in the original species parameter
data.frame, each species is fished by a unique gear named after the species.
This can be seen in the new $gear$ column which holds the names of the
fishing gears.
Also, the selectivity function for each fishing gear has been set in the
$sel\_func$ column (function \code{sigmoid\_length()}).

<<>>=
params@species_params
@

Note also that the species parameter data.frame we passed in to make to the
\code{MizerParams} did not have a \code{catchability} column.
Because of this, the \code{MizerParams()} constructor sets the catchability
for each gear to 1 for each of the species it catches.

In this case, each species is only caught by one gear.
An example of setting the catchability by hand can be seen in
Section\ref{sec:north_sea_example}.

There is a \code{summary()} method for \class{MizerParams} objects
which prints a useful summary of the model parameters:

<<results=hide>>=
summary(params)
@

\subsection{Setting different gears}

In the above example, each species is caught by a different gear (named
after the species it catches). This is the default when there is no $gear$
column in the species parameter data.frame.

Here, we look at an example where we do specify the fishing gears.
We take the original $params\_data$ species parameter data.frame
that was read in above and
bind an additional column, $gear$, to it. This $gear$ column 
contains the name of the gear that catches the species in that row.
Here we set up four different gears: Industrial, Pelagic, Beam Trawl
and Otter Trawl, that catch different combinations of species.

<<>>=
params_data$gear <- c("Industrial","Industrial","Industrial",
		      "Pelagic","Beam Trawl","Otter Trawl",
		      "Beam Trawl","Otter Trawl","Beam Trawl",
		      "Otter Trawl","Otter Trawl","Otter Trawl")
@

If you inspect the \code{params\_data} object you will see a new column, $gear$, has been added to it.  
We then make a new \class{MizerParams} object as before:

<<>>=
params_gears <- MizerParams(params_data, interaction = inter)
@

You can see that the gears in the new \class{MizerParams} object have
been set correctly by examining the $catchability$ slot:
<<>>=
params_gears@catchability
@

A catchability of 0 means that a species is not caught by that gear.
As we didn't
include a \code{catchability} column in the species parameter data.frame
the catchabilities have been set to the default value of 1.

In this example the same gear now catches multiple stocks. For
example, the 'Industrial' gear catches Sprat, Sandeel and Norway Pout.
Why would we want to set up the gears like this?
In the next section we will see that to project the model through time
you need to specify the fishing effort for each gear through time.
By setting the gears up in this way you can run different management
scenarios of changing the efforts of the fishing gears rather than on
individual species.
It also means that after a simulation has been run you can examine
the catches by gear.

\section{Running a simulation}
\label{sec:projection}

In Sections COMM and TRAIT we used the \code{project()} method to perform simple simulations where the fishing effort was held constant through the duration of the simulation.
Here we take a more detailed look at the \code{project()} method.

In \pkg{mizer} simulations are performed using the \code{project()}
method. This method takes a \class{MizerParams} object and projects it
forward through time, starting from an initital population abundance
and with a pre-determined fishing effort pattern.

Running a projection with \code{project()} requires various arguments:
\begin{description}
    \item[A \class{MizerParams} object] The model parameters (see previous
	section);
    \item[Fishing effort] The fishing effort of each gear through time;
    \item[Initial population] The initial abundances of the stocks and the
	background spectrum;
    \item[Time arguments] Arguments to control the time of the simulation,
	including the simulation time step, the length of the simulation
	and how frequently the output is stored.
\end{description}

The help page for \code{project()} describes the arguments in more detail.

The \class{MizerParams} class was explored in the previous section.
In this section we will look at the other arguments and use examples
to perform some simple projections.

\subsection{The time arguments}
\label{sec:time_arguments}

There are three arguments that control the \code{project()} method:
$dt$, $t\_max$ and $t\_save$.

$dt$ is the time step used by the numerical solver in \code{project()}.
This is the time step on which the model operates.
$t\_max$ determines the maximum time of the simulation, i.e. how long
the projection is run for. Note that
this is not necessarily the same as the number of time steps in the model.
The number of time steps in the model is given by $t\_max$ / $dt$.
For example, a simulation with $dt$ = 0.5 and $t\_max$ = 10 will perform
20 time steps.
The default values for $dt$ and $t\_max$ are 1 and 100 respectively.
The final argument is $t\_save$. This sets how frequently 
\code{project()} stores the state of the model in the \class{MizerSim}
object. For example, if $t\_save$ = 2, the state of the model is stored
at t = 0, 2, 4... etc.
$t\_save$ must be a multiple of $dt$. The default value of $t\_save$ is 1.

\subsection{Setting the fishing effort}

The fishing effort argument describes the effort of the fishing gears
in the model through time. Information on the fishing gears and their
selectivities and catchabilities is stored in the \code{MizerParams} argument.

There are three ways of setting the fishing effort. Examples of all three
can be seen in Section~\ref{sec:projection_examples}.

The simplest way is by passing the $effort$ argument as a single number.
This value is then
used as the fishing effort by all of the gears at each time step of the projection,
i.e. fishing effort is constant throughout the simulation and is the same for
all gears. The length of the simulation is determined by the $t\_max$
argument (see Section~\ref{sec:time_arguments}).

Another way of setting the fishing effort is to use a numeric vector
that has the same length as the number of gears.
The values in the vector are used as the fishing effort of each gear
at each time step, i.e. again, the fishing effort is constant
through time but each gear can have a different constant effort.
The order of values in the effort vector must be the same as the order
of gears in the \code{MizerParams} object 
(it may be helpful to name the effort vector after the gears but these names will not actually be used in \code{project()}). 
Again, the length of the simulation is determined by the $t\_max$ argument.

Finally, the most sophisticated way of setting the fishing effort is to
use a two-dimensional array or matrix of values, set up as time step by gear.
Each row of the array has the effort values of each fishing gear
at a time step (the time step is set by the argument $dt$, see above).
This means that it is not necessary to supply a $t\_max$ argument in
this case because the maximum time of the simulation is calculated by the
number of the time steps in the effort array (the first dimension) and
the value of $dt$. If a value for $t\_max$ is also supplied it is ignored.

\subsection{Setting the initial population abundance}
\label{sec:setting_initial_abundances}

When running a simulation with the \code{project()} method,
the initial populations of the species and the background spectrum
need to be specified. These are passed to \code{project()} as the arguments 
$initial\_n$ and $initial\_n\_pp$ respectively.  $initial\_n$ is a matrix
(with dimensions species x size) that contains the initial
abundances of each species at size (the sizes must match those in the species
size spectrum). $initial\_n\_pp$ is a vector of the same length as the
the length of the full spectrum.

By default, the $initial\_n$ argument has values
calculated using KEN ANDERSEN MAGIC.
These are implemented in the function \code{get\_initial\_n()}.
The default value for $initial\_n\_pp$ is the carrying capacity
of the background spectrum, stored in the $cc\_pp$ slot of the
\class{MizerParams} parameters object.

\subsection{What do you get from running \code{project()}?}

Running \code{project()} returns an object of type \class{MizerSim}.
Like the \class{MizerParams} class this has various slots that contain the
output of the simulations.
An object of \class{MizerSim} has four slots, details of which can be seen
in the help page.
The $params$ slot holds the \class{MizerParams} object that was passed
in to \code{project()}.
The $effort$ slot holds the fishing effort of each gear through time.
Note that the $effort$ slot may not be exactly the same as the one passed in
as the $effort$ argument. This is because only the saved effort
 is stored (the frequency of saving is determined by the argument $t\_save$).
The $n$ and $n\_pp$ hold the saved abundances of the species and the
background population at size respectively. 
Note that The $n$ and $n\_pp$ slots have one more row than the $effort$ slot.
This is to the store the initial populations.

\subsection{Projection examples}
\label{sec:projection_examples}

In this section we'll look at how to run simulations with the \code{project()}
method whilst specifying fishing effort in different ways.
We will use the $params\_gears$ object with four gears that was created in the
\class{MizerParams} example above.

\subsubsection{Projections with simple constant effort}
In this first example we will use constant effort through time
for each of the fishing gears and this effort will be used for
all the gears. This means we only need to specify the $effort$ argument
as a single numeric.
As well as thinking about the $effort$ argument we also need to consider
the time parameters.
We will project the populations forward until time equals 10 ($t\_max$ = 10),
with a time step of 1 ($dt$ = 1), saving the output every time step 
($t\_save$ = 1).

<<>>=
sim <- project(params_gears, effort = 1, t_max = 10, dt = 1, t_save = 1)
@

The resulting $sim$ object is of class \class{MizerSim}.
The species abundances at size through time can be seen in the $n$ slot.
This is a three-dimensional array (time x species x size).
Consequently, this array can get very big so inspecting it can be difficult.
A range of summary methods and plots are available to make this job easier.
We will look at those in Section~\ref{sec:exploring}.
In the example we have just run the time dimension of the $n$ slot has 11
rows (one for the initial population and then one for each of 10 
saved time steps). There are also 12 species each with 100 sizes.
We can check this by running the \code{dim()} function and looking at
the dimensions of the $n$ array:

<<>>=
dim(sim@n)
@

To pull out the abundances of a particular species through time at size
you can subset the array. For example to look at Cod through time you
can use:

<<results=hide>>=
sim@n[,"Cod",]
@

The effort through time can be inspected by looking at the $effort$
slot (we use the \code{head()} function to just show the
first few lines).
In this example, we specified the $effort$ argument as a single numeric
of value 1. As you can see this results in the same effort being used for all
gears for all time steps:

<<>>=
head(sim@effort)
@

A \code{summary()} method is also available for objects of type \class{MizerSim}.

<<summary_mizersim,eval=FALSE>>=
summary(sim)
@

If we decrease $dt$ and $t\_save$ but keep $t\_max$ the same then
we can see that the time dimension of the $effort$ slot changes accordingly.
Now the model time step is 0.5 and we store the output at multiples of time = 0.5.
This will also be true of the $n$ and $n\_pp$ slots.

<<>>=
sim <- project(params_gears, effort = 1, t_max = 10, dt = 0.5, t_save = 0.5)
head(sim@effort)
@

As mentioned above, we can also set the effort values for each gear
seperatley using a vector of effort values. This still keeps the efforts
constant through time but it means that each gear can have a different
constant effort.

For example, if we want to switch off the industrial gear (i.e. effort = 0),
keep the pelagic gear effort at 1, and set the effort of both the trawl
gears at 0.5 we set the effort for each gear using a single effort vector,
where the positions of elements in the vector match the position of
the gears:

<<>>=
effort <- c(0,1,0.5,0.5)
@

We then call \code{project()} with this effort and inspect the resulting
$effort$ slot (again we use the \code{head()} function to just show the
first few lines):

<<>>=
sim <- project(params_gears, effort = effort, t_max = 10, dt = 1, t_save = 1)
head(sim@effort)
@

\subsubsection{An example of changing effort through time}

In this example we set up a more complicated fishing effort
structure that allows the fishing effort of each gear to change
through time.
As mentioned above, to do this effort must be supplied as a two dimensional
array or matrix. The first dimension is time step (determined by the
$dt$ argument) and the second dimension is gear.
Also, as mentioned above, if effort is passed in as an array or matrix
then the length of the simulation is determined by the
number of rows in the effort array and $dt$; the argument $t\_max$ is not used.
In our example $params\_gears$ object we have 
\Sexpr{length(unique(params_gears@species_params$gear))}
gears.

In this example, the effort of the industrial gear is held constant at 0.5,
the effort of the pelagic gear is increased linearly from 1 to 2, the effort
of the beam trawl decreases linearly from 1 to 0, whilst the effort of
the otter trawl decreases linearly from 1 to 0.5.
The final dimension of the array is 10 by 4.

<<>>=
effort_array <- cbind(rep(0.5,10),
    seq(from = 1, to = 2, length = 10),
    seq(from = 1, to = 0, length = 10),
    seq(from = 1, to = 0.5, length = 10))
@

The first few rows of the effort array are shown as an illustration:
<<>>=
head(effort_array)
@

The effort array does not need to have dimension names because it
is the order of the columns that is important, not their name.
The order of the columns must match the order of the gears in the
\class{MizerParams} object. 
As you can see in the previous examples, the dimensions of the effort
array do get named when it is processed by \code{project()}.

<<>>=
sim <- project(params_gears,effort=effort_array, dt=1, t_save = 1)
head(sim@effort)
@

It can be quite fiddly to set up a complicated effort array so it may
be easier to prepare it in advance as a .csv file and read it in,
similar to how
we read in the interaction matrix in Section~\ref{sec:params_example}.
We give an example of this in Section~\ref{sec:north_sea_example}.

\section{Exploring the simulation results}
\label{sec:exploring}

In the previous sections we saw how to set up a model and project it
forward through time under our desired fishing scenario.
The result of running a projection is an object of class \class{MizerSim}.
What do we then do?  How can we explore the results of the simulation?
In this section we introduce a range of summaries, plots and indicators
that can be easily produced using methods included in \pkg{mizer}.

\subsection{Summary methods for \class{MizerSim} objects}
\label{sec:summaries}

As well as the \code{summary()} methods that are available for both
\class{MizerParams} and \class{MizerSim} objects, there are some
useful summary methods to pull information out of
a \class{MizerSim} object (see Table~\ref{tab:summary_methods}).
All of these methods have help files to explain how they are used.

(It is also possible to use most of these methods with a \class{MizerParams}
object if you also supply the population abundance as an argument.
This can be useful for exploring how changes in parameter value or abundance
can affect summary statistics and indicators.
We won't explore this here but you can see their help files for more details.)

\begin{table}[ht]
    \begin{center}
	\begin{tabularx}{\linewidth}{r|X|X}
	\hline
	Method & Returns & Description \\
	\hline
	getSSB() & Two dimensional array (time x species) & Total Spawning Stock Biomass (SSB) of each species through time where SSB is calculated as EQUATION.\\
	getBiomass() & Two dimensional array (time x species) & Total biomass of each species through time.\\
	getN() & Two dimensional array (time x species) & Total abundance of each species through time.\\
	%getPhiPrey() & & \\
	getFeedingLevel() & Three dimensional array (time x species x size) & Feeding level of each species by size through time. \\
	%getPredRate() & &\\
	%getM2() & & \\
	getFMort() & Three dimensional array (time x species x size) & Total fishing mortality on each species by size through time.\\
	getFMortGear() & Four dimensional array (time x gear x species x size) & Fishing mortality on each species by each gear at size through time.\\
	%getZ() & & \\
	%getRDI & & \\
	%getRDD & & \\ % Need to add these
	getYieldGear() & Three dimensional array (time x gear x species) & Total yield by gear and species through time. \\
	getYield() & Two dimensional array (time x species) & Total yield of each species across all gears through time. \\
	\hline
	\end{tabularx}
	\caption{Summary methods for \class{MizerSim} objects.}
	\label{tab:summary_methods}
    \end{center}
\end{table}

%size_range
%Biomass
%N

The methods \code{getBiomass()} and \code{getN()} have additional arguments
that allow the user to set the size range over which to calculate the 
summary statistic.
This is done by passing in a combination of the arguments \code{min\_l}, 
\code{min\_w}, \code{max\_l} and \code{max\_w} for the minimum and maximum length or weight.
If \code{min\_l} is specified there is no need to specify \code{min\_w} and
so on. However, if a length is specified (minimum or maximum) then it is
necessary for the species parameter data.frame (see
Section~\ref{sec:species_parameters_dataframe}) to include the parameters
$a$ and $b$ for length-weight conversion.
It is possible to mix length and weight constraints, e.g. by supplying
a minimum weight and a maximum length.
The default values are the minimum and maximum weights of the spectrum.

\subsubsection{Examples of using the summary methods}
\label{sec:summaries_example}

Here we show a simple demonstration of using a summary method.
We first create a \class{MizerSim} object by projecting the parameters
set up earlier through time. We then use \code{getSSB()} to calculate the
SSB of each species through time.

<<>>=
sim <- project(params,effort=0.5, t_max = 10, dt=1, t_save = 1)
ssb <- getSSB(sim)
head(ssb)
@

As you can see, \code{getSSB()} calculates the SSB for each species though time. The time dimension depends on the value of the argument $t_save$ when \code{project()} was run.

As mentioned above, we can specify the size range of some of the methods.
For example, here we calculate the total biomass of each species but only
include individuals that are longer than 10 cm and shorter than 50 cm.

<<>>=
biomass <- getBiomass(sim, min_l = 10, max_l = 50)
head(biomass)
@

\subsection{Methods for calculating indicators}

Methods have been set up to calculate a range of indicators from a
\class{MizerSim} object after a projection. These
can be seen in Table~\ref{tab:indicator_methods}.
You can read the help pages for each of the methods for full instructions
on how to use them, along with examples.

With all of the methods in the table it is possible to specify the size
range of the community to be used in the calculation (e.g. to exclude very
small or very large individuals) so that the calculated metrics can be
compared to empirical data.
This is used in the same way that we saw with the method
\code{getBiomass()} in Section~\ref{sec:summaries}.
It is also possible to specify which species to include in the calculation.
See the help files for more details.

\begin{table}[ht]
    \begin{center}
	\begin{tabularx}{\linewidth}{r|X|X}
	\hline
	Method & Returns & Description \\
	\hline
	getProportionOfLargeFish() & A vector with values at each time step. & Calculates the proportion of large fish through time. The threshold value can be specified. It is possible to calculation the proportion of large fish based on either length or weight. \\
	getMeanWeight() & A vector with values at each saved time step.  & The mean weight of the community through time. This is calculated as the total biomass of the community divided by the total abundance.\\
	getMeanMaxWeight() & Depends on the $measure$ argument. If $measure$ == $both$ then you get a matrix with two columns, one with values by numbers, the other with values by biomass at each saved time step. If $measure$ = $numbers$ or $biomass$ you get a vector of the respective values at each saved time step. & The mean maximum weight of the community through time. This can be calculated by numbers or by biomass. See the help file for more details.\\
	getCommunitySlope() & A data.frame with four columns: time step, slope, intercept and $R^2$ value. & Calculates the slope of the community abundance spectrum through time by performing a linear regression on the logged total numerical abundance and logged body size. \\
	\hline
	\end{tabularx}
	\caption{Indicator methods for \class{MizerSim} objects.}
	\label{tab:indicator_methods}
    \end{center}
\end{table}

\subsubsection{Examples of calculating indicators}
\label{sec:indicators_example}

Here we show a simple demonstration of using indicator methods.
We first create a \class{MizerSim} object by projecting the parameters
set up earlier through time. 

<<>>=
sim <- project(params,effort=0.5, t_max = 10, dt=1, t_save = 1)
@

The slope of the community can be calculated using the 
\code{getCommunitySlope()} method. Initially we include all species and
all sizes in the calculation (only the first five rows are shown):

<<>>=
slope <- getCommunitySlope(sim)
head(slope)
@

See the help file for \code{getCommunitySlope} for an explanation of what the columns are.

We can include only the species we want with the $species$ argument.
Here we only include demersal species.
We also restrict the size range of the community that is used in the
calculation to between 10 g and 5 kg.

<<>>=
dem_species <- c("Dab","Whiting","Sole","Gurnard","Plaice","Haddock",
    "Cod","Saithe")
slope <- getCommunitySlope(sim, min_w = 10, max_w = 5000, 
    species = dem_species)
head(slope)
@

\subsection{Plotting the results}

\R is very powerful when it comes to exploring data through plots.
A useful package for plotting is \pkg{ggplot2}.
\pkg{ggplot2} uses data.frames for input data. Many of the summary
methods and slots of the \pkg{mizer} classes are arrays or matrices.
Fortunately it is straightforward to turn arrays and matrices into
data.frames using the command \code{melt} which is in the \pkg{reshape}
package.
It is probably worth your time getting to grips with these packages to make
plotting easier.

%PERHAPS INCLUDE EXAMPLE OF USING GGPLOT WITH MIZER BELOW?

Included in \pkg{mizer} are several dedicated plots that use
\class{MizerSim} objects as inputs (see Table~\ref{tab:plots}).
As well as displaying the plots, these methods all return objects of
type \class{ggplot} from the \pkg{ggplot2} package.
See the help page of the individual plot methods for more details.
The generic \code{plot()} method has also been overloaded for
\class{MizerSim} objects. This produces several plots in the same window
to provide a snapshot of the results of the simulation.

Some of the plots plot values by size (for example \code{plotFeedingLevel()}
and \code{plotSpectra()}).
For these plots, the default is to use the data at the final time
step of the projection.
With these plotting methods, it is also possible to specify a different time
step to plot or a time range to average the values over before plotting. 

\begin{table}[ht]
    \begin{center}
	\begin{tabularx}{\linewidth}{r|X}
	\hline
	Plot & Description \\
	\hline
	plotBiomass() & Plots the total biomass of each species through time. The size range of the community can be specified in the same way as the method \code{getBiomass()}.\\
	plotSpectra() & Plots the abundance (biomass or numbers) spectra of each species and the background community. It is possible to specify a minimum size which is useful for truncating the plot. \\
	plotFeedingLevel() & Plots the feeding level of each species against size.\\
	plotM2() & Plots the predation mortality of each species against size.\\
	plotFMort() & Plots the total fishing mortality of each species against size.\\
	plotYield() & Plots the total yield of each species across all fishing gears against time.\\
	plotYieldGear() & Plots the total yield of each specis by gear against time.\\
	plot() & Produces 5 plots (\code{plotFeedingLevel()}, \code{plotBiomass()}, \code{plotM2()}, \code{plotFMort()} and \code{plotSpectra()}) in the same window as a summary.\\
	\hline
	\end{tabularx}
	\caption{Plot methods for \class{MizerSim} objects.}
	\label{tab:plots}
    \end{center}
\end{table}

\subsubsection{Plotting examples}
\label{sec:plot_examples}

Using the plotting methods is straightforward.
For example, to plot the total biomass of each species against
time you use the \code{plotBiomass()} method:
<<eval=FALSE>>=
plotBiomass(sim)
@

The outcome of which can be seen in Figure~\ref{fig:plotBiomass_example}.
\begin{figure}
<<label=plotBiomass_example, fig=TRUE, echo=FALSE>>=
    p <- plotBiomass(sim)
    print(p)
@
\caption{An example of using the \code{plotBiomass()} method.}
\label{fig:plotBiomass_example}
\end{figure}

As mentioned above, some of the plot methods plot values against size
at a point in time (or averaged over a time period).
For these plots it is possible to specify the time step to plot,
or the time period to average the values over. The default is to use
the final time step.
Here we plot the abundance spectra (biomass), averaged over time = 5 to 10
(the simulation was projected until $t$ = 10; see
Figure~\ref{fig:plotSpectra_example}):

<<eval=FALSE>>=
plotSpectra(sim, time_range = 5:10, biomass=TRUE)
@

\begin{figure}
<<label=plotSpectra_example, fig=TRUE, echo=FALSE>>=
p <- plotSpectra(sim, time_range = 5:10, biomass=TRUE)
print(p)
@
\caption{An example of using the \code{plotSpectra()} method, plotting values averaged over the period $t$ = 5 to 10.}
\label{fig:plotSpectra_example}
\end{figure}

As mentioned above, the generic \code{plot()} method has also been
overloaded.% (see Figure~\ref{fig:plot_example}).
This produces 5 plots in the same window (\code{plotFeedingLevel()},
\code{plotBiomass()}, \code{plotM2()}, \code{plotFMort()} and
\code{plotSpectra()}). It is possible to pass in the same arguments that
these plots use, e.g. arguments to change the time period over which the
data is averaged.

<<label=demo_summary_plot,eval=FALSE>>=
plot(sim)
@

\begin{figure}
<<label=plot_example, fig=TRUE, echo=FALSE>>=
<<demo_summary_plot>>
@
\caption{Example output from using the summary \code{plot()} method.}
\label{fig:plot_example}
\end{figure}

%------------------------------------------------------------------------------------
\section{A detailed example using the North Sea}
\label{sec:north_sea_example}

Here we give a detailed example of projecting a fishery through time
using historical levels of fishing effort.
We use data from the North Sea from 1957 to 2010 and compare the simulated
population trajectories to the best estimates of abundance from ICES where
available.

\subsection{Setting up the North Sea model}

As before, we load the species and interaction parameters for the North Sea.
Note that we are the using dataset without fishing gears because in
this example, we want to control the individual levels of effort on each
species. 

<<label = load_ns_species_params>>=
params_data <- read.csv("simple_species_params.csv")
inter <- as(read.csv("inter.csv", row.names=1),"matrix")
@

The historical fishing mortality from 1967 to 2010 for each species is stored
in the csv file \code{f\_history.csv}.
As before, we can use the \code{read.csv()} to read in the data. This
reads the data in as a \class{data.frame}. We want this to
be a \class{matrix} so we use the \code{as.matrix()} function:

<<label=load_f_history>>=
f_history <- as.matrix(read.csv("f_history.csv",row.names=1))
@

We can take a look at the first years of the data.
<<label=head_f_history>>=
head(f_history)
@

Note that the order of the species in the \code{f\_history} object is
the same as that in the species parameters data.frame.
This has to be the case.

As mentioned in Section~\ref{sec:fishing_gear}, fishing mortality is
calculated as a combination of
selectivity, catchability and fishing effort.
The values in \code{f\_history} are absolute levels of fishing mortality.
To use the \code{project()} method we need to provide a matrix of fishing
effort that will result in these historical fishing mortality levels.

One way of doing this is to set the catchability of all species to 1
and then use the \code{f\_history} matrix as the fishing effort.
However, it is probably clearer to use the effort relative to a
particular year.  Here we use the year 1990.
To do this we set the catchability of each species to be the same as
fishing mortality in 1990. 
This means that a relative effort of 1 in 1990 will result
in the fishing mortality being what it was in 1990.

The catchability can be set by either including a 'catchability' column
in the species parameters data.frame, or by manipulating the catchability
slot directly after the \class{MizerParams} object has been created.
Here we use the former method.

<<label=set_catchability>>=
params_data$catchability <- as.numeric(f_history["1990",])
@

We are going to use the default stock-recruitment function for each of the
species (see Section~\ref{sec:srr}).
This uses the parameter \code{r\_max} which means that we need
to set values of this parameter for all species.
This can be done by including an 'r\_max' column in the species
parameters data.frame.
These values are taken from NS PAPER REFERENCE. The values were found
through a calibration process which is not covered here but will be added to
a later version of this manual. 

<<label=set_r_max>>=
params_data$r_max <- c(5.43e11,3.65e11,1.51e12,4.40e12,3.34e11,
2.68e10,1.16e09,1.27e10,1.00e18,6.20e10, 5.26e08,1.65e10)
@

We can now create the \code{MizerParams} object using the species
parameters data.frame.

<<label=make_ns_params>>=
params <- MizerParams(params_data, inter)
@

Here we check that the catchability has been
set correctly by inspecting the diagonal of the catchability slot.
<<label=check_catchability>>=
diag(params@catchability)
@

Now we can make the matrix of relative effort through time that will
be used with the \code{project()} method.
To do this we want rescale the \code{f\_history} object to 1990 so that
the relative effort in 1990 = 1.
We then check a few rows of the effort matrix to check this has happened:

<<label=rescale_effort>>=
effort <- sweep(f_history,2,f_history["1990",],"/")
effort[as.character(1988:1992),]
@

We could just project forward with these relative efforts. However,
the population dynamics in the early years will be strongly
determined by the initial population abundances (known as the transient
behaviour - essentially the initial behaviour before the long term dynamics
are reached).
As this is fisheries science, we don't know what the initial abundance are.
One way around is this to project forward at a constant fishing effort
equal to the first year of historical relative effort until equilibrium
is reached.
We then can carry on projecting forward using the remaining years of effort.
This approach reduces the impact of transient dynamics.

Here we make an inital effort matrix of 100 years at the first effort level,
and then stick it on top of the original matrix of historical relative
effort:

<<>>=
initial_effort <- matrix(effort[1,],byrow=TRUE, nrow=100,ncol=ncol(effort))
effort <- rbind(initial_effort,effort)
@

\subsection{Running the simulation}

We now have our parameter object and out matrix of efforts relative to 1990.
This includes an initial 100 years of constant relative effort at the
1957 level, followed by the relative effort from 1957 to 2010
We can use this effort matrix as an argument to the \code{project()} method.
We use \code{dt} = 1 and save the results every year.

<<>>=
sim <- project(params, effort=effort, dt = 1, t_save = 1)
@

Plotting the results, we can see how the biomasses of the stocks change
over time (Figure~\ref{fig:plot_ns_biomass}).
You can see the 100 year period of transients with constant fishing effort
as the dynamics approach equilibrium before the historical
relative effort is used.


<<eval=FALSE>>=
plotBiomass(sim)
@

\begin{figure}
<<label=plot_ns_biomass, fig=TRUE, echo=FALSE>>=
p <- plotBiomass(sim)
print(p)
@
\caption{Simulated biomasses of stocks in the North Sea with 100 years of transients.}
\label{fig:plot_ns_biomass}
\end{figure}



Compare outputs to ICES data.

Bring in some bits from NS PAPER

%\section{Under the hood of \pkg{mizer}: notes for developers}
%
%Still to come.
%
%Classes and whatnot



\section{Acknowledgements}

The authors of the \pkg{mizer} package would like to thank the authors
of the \pkg{abc} package for allowing them to use some of the introductory
text from their vignette.

Finlay Scott would like to thank the Cefas Seedcorn Project DP266
and the Defra project MF1225 for supporting this work.

%-------------------------------------------------------------------------
% References
%------------------------------------------------------------------------

\bibliography{reflib}{}
%\bibliographystyle{plain}
\bibliographystyle{plainnat}

\end{document}

